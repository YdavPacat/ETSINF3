{
	"pages": [
		{"title": "Avaluació", "text": "Avaluació\n\nTres pruebas\nTodas individuales y recuperables. \nSe exige un mínimo del 30% en cada prueba \n\n\n\n\n\n\nPrueba\nfecha\npuntos \n\n\n\n\nParcial l\n28 octubre\n4 (3+1)\n\n\nPráctica 2\n??\n2 \n\n\nParcial 2\n??\n4 (3+1)\n\n\n\n\nTemario de los parciales\n\nParcial 1\nTeoria temas 1,2 parte inicial del 3 (3 puntos)\nPráctica 1:                 (1 punto)    \n\n\nParcial 2\nTeoria temas 3 (parte final),4,5,6 (3 puntos)\nPráctica 3:                 (1 punto)    \n\n\n\n\nEstructura de las pruebas\n\nLos parciales son pruebas tipo test (cuestiones de opció multiple) \nLa prueba de la práctica 2 puede tener parte de respuesta abierta \n\n\nRecuperación\n\nPueden recuperarse las partes que se deseen \nEn cada parte recuperada, la nota de recuperación prevalece sobre la original\n\n\n\n", "tags": "", "url": "avaluacio.html"},
		{"title": "Metodologia: docencia inversa", "text": "Metodologia: docencia inversa\nSe propone la utilización de la metodología de docencia inversa (flip-teaching)\nLa UPV dispone de un Blog del Proyecto de Docencia Inversa (https://docenciainversa.blogs.upv.es/proyecto-clase-inversa-upv-2/), en el que encontrarás todos los detalles. \nSe basa en la cooperación entre el docente y el alumno, y por tanto requiere el compromiso de ambos:\nEl docente: \n\nOrienta el trabajo del alumno e indica los pasos a seguir \n\nOfrece explicaciones, aclaraciones, y resuelve dudas \n\nAyuda a obtener los resultados de aprendizaje planteados, encaminados a la mejora del perfil profesional y la adquisición de unas competencies básicas necesarias en la titulación. \n\n\nEl alumno: \n\nRealiza el trabajo continuo que plantea el docente. Requiere trabajo diario, pero planteado de forma progresiva y adaptada al nivel exigido en esta materia. \n\nEntrega el trabajo realizado dentro del calendario publicado. \n\nConsulta y requeriere ajuda al docent cuando lo necesita. \n\n\nEl objetivo es: \n\nConseguir mejores resultados académicos \n\nMejorar el aprendizaje, no sólo en cuanto a conocimientos adquiridos en ese momento, sino también mas perdurables en el tiempo. \n\nDesarrollar competencias transversales, como pueden ser: trabajo en equipo, comunicación oral, gestión del tiempo ... (mejora de tu currículum profesional). \n\n\n", "tags": "", "url": "docenciainversa.html"},
		{"title": "Funciones síncronas, asíncronas y callbacks", "text": "\nFunciones síncronas, asíncronas y callbacks\nTSR 2018-19 Francisco Torres\n\n\nLo que ya sabemos\n\nUna función síncrona se ejecuta cuando se invoca\nEj funciones síncronas para lect/escrit. de ficheros:var fs = require(&#39;fs&#39;);\nfs.writeFileSync(&#39;mydata.txt&#39;, &#39;Hello Node.js\\nHello everybody!&#39;);\nvar buffer = fs.readFileSync(&#39;mydata.txt&#39;);\nconsole.log(buffer.toString());\nconsole.log(&#39;ejecutando otras instrucciones&#39;);\nconsole.log(&#39;raiz(2) =&#39;, Math.sqrt(2));\n\nHello Node.js\nHello everybody!\nejecutando otras instrucciones\nraiz(2) = 1.4142135623730951\n\n\n\n\n\nEjecución asíncrona\n\nLa lectura de un fichero puede ser una acción bloqueante del flujo de ejecución.\nEs conveniente disponer una variante ASÍNCRONA de esta operación, que la ejecute en 2º plano, sin bloquear el resto del programa.\nNode.js proporciona funciones predefinidas con comportamiento asíncrono. Por ejemplo, usemos readFile en el anterior programa:var fs = require(&#39;fs&#39;);\nfs.writeFileSync(&#39;mydata.txt&#39;, &#39;Hello Node.js\\nHello everybody!&#39;);\nfs.readFile(&#39;mydata.txt&#39;);\nconsole.log(&#39;ejecutando otras instrucciones&#39;);\nconsole.log(&#39;raiz(2) =&#39;, Math.sqrt(2));\n\n\nAhora bien, dado que no se ha especificado un 2º argumento de la función readFile, la salida en consola es:ejecutando otras instrucciones\nraiz(2) = 1.4142135623730951\n\n\n\n\n¿Cómo se debe invocar una función asíncrona?\n\nEs necesario proporcionar, como argumento, una función que contenga las operaciones a realizar cuando termine la ejecución de la función asíncrona.\nConsideremos los perfiles de las funciones de lectura de ficheros:\nLa función síncrona: fs.readFileSync(path[, options])\nLa función asíncrona: fs.readFile(path[, options], callback)\nDonde:\npath es la ruta del fichero a leer\noptions son argumentos opcionales sobre el modo de lectura\ncallback es un función, a invocar cuando termine la ejecución de la función asíncrona\n\n\n\n\nConsideremos de nuevo el programa anterior, especificando una función callback muy simple:var fs = require(&#39;fs&#39;);\nfs.writeFileSync(&#39;mydata.txt&#39;, &#39;Hello Node.js\\nHello everybody!&#39;);\nfs.readFile(&#39;mydata.txt&#39;, function () { console.log(&quot;Fichero leído&quot;); });\nconsole.log(&#39;ejecutando otras instrucciones&#39;);\nconsole.log(&#39;raiz(2) =&#39;, Math.sqrt(2));\n\n\nAhora, la salida en consola es:ejecutando otras instrucciones\nraiz(2) = 1.4142135623730951\nFichero leído\n\n\n\n\n¿Cómo se debe invocar una función asíncrona? (ii)\n\nEn nuestro ejemplo, deseamos mostrar el contenido del fichero, no un mensaje &quot;Fichero leído&quot;.\nLa función callback necesita 2 argumentos:\nEl primer argumento, err, contendrá información de error, en el caso de que la ejecución de la función asíncrona haya tenido algún problema. \nEl segundo argumento, data, contendrá el resultado de la función asíncrona, si esta ha terminado sin error.\n\n\nEn el caso de lectura de fichero, data guarda el contenido del fichero y err una descripción del fallo de la lectura (por ejemplo, que el fichero no exista).\nEn nuestro ejemplo, podríamos escribir la siguiente función callback:var myCB = function (err, data) {\n if (err) console.error(err.stack);\n else console.log(data.toString());\n}\n\n\nY pasarla como argumento en la lectura asíncrona de fichero:var fs = require(&#39;fs&#39;);\nfs.writeFileSync(&#39;mydata.txt&#39;, &#39;Hello Node.js\\nHello everybody!&#39;);\nfs.readFile(&#39;mydata.txt&#39;, myCB);\nconsole.log(&#39;ejecutando otras instrucciones&#39;);\nconsole.log(&#39;raiz(2) =&#39;, Math.sqrt(2));\n\n\nAhora, la salida en consola es la deseada:ejecutando otras instrucciones\nraiz(2) = 1.4142135623730951\nHello Node.js\nHello everybody!\n\n\n\n\n¿Cómo se debe invocar una función asíncrona? (iii)\n\nCompletemos el ejemplo anterior, añadiendo la lectura de un fichero inexistente:var fs = require(&#39;fs&#39;);\nvar myCB = function (err, data) {\n if (err) console.error(err.stack);\n else console.log(data.toString());\n}\nfs.writeFileSync(&#39;mydata.txt&#39;, &#39;Hello Node.js\\nHello everybody!&#39;);\nfs.readFile(&#39;mydata.txt&#39;, myCB);\nfs.readFile(&#39;nothing.txt&#39;, myCB);\nconsole.log(&#39;ejecutando otras instrucciones&#39;);\nconsole.log(&#39;raiz(2) =&#39;, Math.sqrt(2));\n\n\nLa salida en consola es:ejecutando otras instrucciones\nraiz(2) = 1.4142135623730951\nError: ENOENT: no such file or directory, open &#39;C:\\ ... \\nothing.txt&#39;\n  at Error (native)\nHello Node.js\nHello everybody!\n\n\n\n\nMás ejemplos\n\nSupongamos que se sabe que el fichero a leer contiene nada más que números enteros, y que se quieren leer y duplicar todos ellos, mostrando el resultado.\nEl siguiente programa sería válido:var fs = require(&#39;fs&#39;);\nfs.writeFileSync(&#39;mydata.txt&#39;, &#39;1 2 3 4 5 6 7 8&#39;);\nvar g = function (str) {\n  var numbers = str.split(&quot; &quot;);\n  var doubles = numbers.map(function(a) {return 2 * a});\n  console.log(doubles);    \n}\nvar f = function (err, data) {\n if (err) console.error(err.stack);\n else g(data.toString());\n}\nfs.readFile(&#39;mydata.txt&#39;, f);\nconsole.log(&#39;ejecutando otras instrucciones&#39;);\nconsole.log(&#39;raiz(2) =&#39;, Math.sqrt(2));\n\n\nSu salida en consola:ejecutando otras instrucciones\nraiz(2) = 1.4142135623730951\n[ 2, 4, 6, 8, 10, 12, 14, 16 ]\n\n\n\n\n", "tags": "", "url": "extra/callbacks.html"},
		{"title": "Funciones síncronas, asíncronas y callbacks", "text": "\nFunciones síncronas, asíncronas y callbacks\nTSR 2018-19 Francisco Torres\n\n\nLo que ya sabemos\n\nUna función síncrona se ejecuta cuando se invoca\nEj readFileSync lee un fichero de forma síncrona, writeFileSync escribe fichero de forma síncrona:var fs = require(&#39;fs&#39;);\nfs.writeFileSync(&#39;mydata.txt&#39;, &#39;Hello Node\\nHello boys!&#39;)\nvar buffer = fs.readFileSync(&#39;mydata.txt&#39;)\nconsole.log(buffer.toString())\nconsole.log(&#39;ejecutando otras instrucciones&#39;)\nconsole.log(&#39;raiz(2) =&#39;, Math.sqrt(2));\n\nHello Node\nHello boys!\nejecutando otras instrucciones\nraiz(2) = 1.4142135623730951\n\n\n\n\n\nEjecución asíncrona\n\nLa variante asíncrona ejecuta la operación en 2º plano (no bloquea al resto del programa)\nMuchas funciones predefinidas en Node tienen comportamiento asíncrono (ej readFile)var fs = require(&#39;fs&#39;);\nfs.writeFileSync(&#39;mydata.txt&#39;, &#39;Hello Node\\nHello boys!&#39;)\nfs.readFile(&#39;mydata.txt&#39;) // ???? como se invoca\nconsole.log(&#39;ejecutando otras instrucciones&#39;)\nconsole.log(&#39;raiz(2) =&#39;, Math.sqrt(2))\n\nejecutando otras instrucciones\nraiz(2) = 1.4142135623730951\n\n\n\n\nInvocación función asíncrona\n\nDebe proporcionar como último argumento una función callback\nCompara las funciones de lectura de ficheros:\nSíncrona: fs.readFileSync(path[, options])\nAsíncrona:fs.readFile(path[, options], callback)\n\n\npath = ruta del fichero a leer\noptions = opciones sobre el modo de lectura\ncallback = función a invocar cuando termine la ejecución de la función asíncrona\n\n\nInvocación función asíncrona ...\n\nAñadimos una función callback al ejemplo:var fs = require(&#39;fs&#39;);\nfs.writeFileSync(&#39;mydata.txt&#39;, &#39;Hello Node\\nHello boys!&#39;)\nfs.readFile(&#39;mydata.txt&#39;, ()=&gt;{console.log(&quot;leido&quot;)})\nconsole.log(&#39;ejecutando otras instrucciones&#39;)\nconsole.log(&#39;raiz(2) =&#39;, Math.sqrt(2))\n\nejecutando otras instrucciones\nraiz(2) = 1.4142135623730951\nleido\n\n\n\n\nInvocación función asíncrona ...\n\nPero deseamos mostrar el contenido del fichero, no un mensaje leido\nLa función callback necesita 2 argumentos (err,data):\nSi la función asíncrona se ejecuta sin errores, data contiene su resultado\nSi hay un error en la ejecución de la función síncrona, err contiene info. sobre el error\n\n\n\n\nInvocación función asíncrona ...\n\nEjecución sin erroresvar fs = require(&#39;fs&#39;);\nvar myCB = function (err, data) {\n if (err) console.error(err.stack)\n else console.log(data.toString())\n}\nfs.writeFileSync(&#39;mydata.txt&#39;, &#39;Hello Node\\nHello boys!&#39;)\nfs.readFile(&#39;mydata.txt&#39;, myCB)\nconsole.log(&#39;ejecutando otras instrucciones&#39;)\nconsole.log(&#39;raiz(2) =&#39;, Math.sqrt(2))\n\nejecutando otras instrucciones\nraiz(2) = 1.4142135623730951\nHello Node\nHello boys!\n\n\n\n\nInvocación función asíncrona ...\n\nCuando intenta leer fichero inexistentevar fs = require(&#39;fs&#39;);\nvar myCB = function (err, data) {\n if (err) console.error(err.stack)\n else console.log(data.toString())\n}\nfs.readFile(&#39;none&#39;, myCB)\nconsole.log(&#39;ejecutando otras instrucciones&#39;)\nconsole.log(&#39;raiz(2) =&#39;, Math.sqrt(2))\n\nejecutando otras instrucciones\nraiz(2) = 1.4142135623730951\nError: ENOENT: no such file or directory, open &#39;...\\none&#39;\n  at Error (native)\n\n\n\n\nOtro ejemplo\n\nLee y procesa números desde ficherovar fs = require(&#39;fs&#39;)\nfs.writeFileSync(&#39;mydata.txt&#39;, &#39;1 2 3 4 5 6 7 8&#39;)\nvar doble = (str) =&gt; str.split(&quot; &quot;).map(n =&gt; 2*n)\nvar f = function (err, data) {\n if (err) console.error(err.stack)\n else console.log(doble(data.toString()))\n}\nfs.readFile(&#39;mydata.txt&#39;, f)\nconsole.log(&#39;ejecutando otras instrucciones&#39;)\nconsole.log(&#39;raiz(2) =&#39;, Math.sqrt(2))\n\nejecutando otras instrucciones\nraiz(2) = 1.4142135623730951\n[ 2, 4, 6, 8, 10, 12, 14, 16 ]\n\n\n\n", "tags": "", "url": "extra/callbacksAdaptadoTranspas.html"},
		{"title": "Concepto de clausura", "text": "\nConcepto de clausura\nTSR 2018-19 Juansa Sendra\n\nLo que ya sabemos\n\nfunción $\\rightarrow$ computación pendiente\nSe utiliza en (casi) todos los leng. de progr.\nLa declaración indica:\nparámetros formales\ncuerpo = expresión o grupo de sentenciasfunction min (x, y) {\nif (x&lt;y) \n   return x\nelse \n   return y\n}\n\n\n\n\n\n\nLo que ya sabemos\n\nPuede aplicarse (invocarse) N veces, indicando en cada aplicación la lista de argumentos\nEvalúa los argumentos, y con esos valores inicializa los parámetros formales\nCrea un entorno local con los parámetros y las vars. locales definidas en la función\nEjecuta el cuerpo y devuelve un valor\nDestruye el entorno local\n\n\n\nconsole.log(min(4,87))  // x=4, y=87\nconsole.log(min(2,4))   // x=2, y=4\nconsole.log(min(2+2, min(3,27)) // x=4, y=(x=3, y=27)-&gt;3\n\n\n¿Qué aporta la Prog. funcional?\nfirst-class functions: La función es un tipo de datos\n\nFunciones anónimas (literal función) (x) =&gt; x*2\nPodemos asignar una función a una variable const doble = (x) =&gt; x*2\nPodemos pasar una función como argumento [1,3,5,7].map(doble) // [2,6,10,14]\nPodemos devolver una función como resultadoconst prod = (a) =&gt; (b) =&gt; a*b\nconst doble = prod(2), triple = prod(3)\nconsole.log(doble(5), triple(4)) // escribe 10 y 12\n\n\n\n\nFirst-class functions\n\nA las variables locales de una función les podemos asignar otras funciones\nanidación = definir una función dentro de otra\n\n\nlexical scoping: una función accede a:\nsu entorno local\nel entorno de cada función en la que está contenida, hasta llegar al entorno global\nvariable libre: variable usada por una función pero definida fuera de su entorno local\nclausura = función que accede a vars libres\n\n\n\n\n\n\nFirst-class functions\nconst hipotenusa = (a,b) {\n   const sqr = (x) =&gt; x*x  // anidacion\n   const sqrt = (x) =&gt; .... // anidacion\n   return sqrt( sqr(a) + sqr(b) )\n}\n\nconst prod = (a) =&gt; (b) =&gt; a*b\n/* en la función (b) =&gt; a*b\n   la variable a es libre\n   (corresponde al contexto de su función &#39;padre&#39;)\n   Dicha funcion es una clausura\n*/\n\n\nHigher-order functions\nSon aquellas funciones que reciben como argumento o devuelven como resultado otra función\n\nPuede estar predefinida (o definida en biblioteca)\n\nArray.map(f) genera un nuevo array resultado de aplicar la función f sobre cada item del array\nsetTimeout(f,ms) programa la invocación de la función f para dentro de ms milisegundos\nemisor.on(&#39;ev&#39;, f) asocia la invocación de la función f a la llegada del evento ev generado por emisor\n\n\n\n\nHigher-order functions\n\nY también puede definirlas el programador\n`js\nconst compose   = (a,b) =&gt; (c) =&gt; a(b(c)) // higher-order\nconst siguiente = (x) =&gt; x+1\nconst anterior  = (x) =&gt; x-1\nconst doble     = (x) =&gt; x*2\nconst mitad     = (x) =&gt; x/2\n\nlet a = [1,3,5,7]\na.map( compose(doble,anterior) )  // [0,4,8,12]\na.map( compose(mitad,siguiente) ) // [1,2,3,4]\n---\n#### Clausura (función que accede a vars libres)\n- Implementación compleja :cry:\n  - Una clausura puede invocarse en distintos momentos\n  - Debe garantizarse la existencia de los contextos anidados necesarios\n    - Una función **no** destruye su contexto local cuando termina si puede requerirse para la futura activación de una clausura\n    - La función inspecciona su entorno y clausura (cierra) los contextos anidados necesarios\n\n---\n#### Clausura (función que accede a vars libres)\n\n- La complejidad de la implementación es transparente para el programador :smile:\n  - La resuelve el soporte para ejecución\n\n- .. y además resulta útil para implementar :smile:\n\n    - callbacks\n    - timeouts\n    - proyección de argumentos\n    - familias de funciones relacionadas\n    - E/S asincrónica\n    - Gestión de eventos\n\n---\n## Comprobemos si ha quedado claro\n\n- razona cuál debería ser el resultado de evaluar esta expresión `((x) =&gt; (y) =&gt; x)(1)(2)`\n- razona porqué esta función siempre devuelve true con independencia del argumento que se le pase `(x) =&gt; ((r1,r2) =&gt; r1 === r2)(x,x)`\n- Compara los dos fragmentos de código de la transparencia siguiente, e intenta establecer el resultado final en ambos\n\n---\n\n```js\nconst f = function () {\n   for (var i=0; i&lt;3; i++) {\n      setTimeout( \n          () =&gt; console.log(i), \n          1000)\n   }\n}\nf()\nconst f = function () {\n   for (var i=0; i&lt;3; i++) {\n      ((c) =&gt; {setTimeout( \n                () =&gt; console.log(c), \n                1000)\n      })(i)\n   }\n}\nf()\n\n", "tags": "", "url": "extra/clausuras.html"},
		{"title": "Eventos en NodeJS", "text": "\nEventos en NodeJS\nTSR 2021 Juansa Sendra, Grupo B\n\nEventos\n\nLa práctica totalidad del API de nodeJS utiliza una arquitectura asincrónica dirigida por eventos\nUn emisor puede generar distintos tipos de eventos, identificados mediante un nombre (string)\nEj: un stream emite &#39;close&#39;, &#39;drain&#39;, &#39;error&#39;, &#39;finish&#39;, &#39;pipe&#39;, &#39;unpipe&#39;\nEj: un socket emite &#39;close&#39;, &#39;connection&#39;, &#39;error&#39;, &#39;listening&#39;\n\n\nPodemos asociar una o más acciones a cada evento\ncada acción es un callback y representa actividades pendientes\nestablece un orden: mantiene un vector de acciones por evento, y se activan por orden \n\n\n\n\nEn nuestros programas podemos tratar esos eventos, pero también declarar emisores de nuevos eventos\nPara poder definir emisores de eventos necesitamos el módulo events\n\n\n\n\nEventos.- Estructura aplicación\n\nSi todos los eventos son externos (API)\nEj.- eventos de teclado, a través de sockets, etc.\nasociar accions a los eventos\n\n\nSi creamos eventos internos (desde el propio programa)\nimportar la biblioteca events\ncrear un emisor (o varios)\nasociar acciones a los eventos\nemitir eventos\nEs habitual utilizar setTimeout o setInterval\nsetTimeout(f,ms) // programa f para ejecutarse tras ms milisegundos\nsetInterval(f,ms) // repite la ejecución de f cada ms milisegundos\n\n\n\n\n\n\nEventos.- Emisor\n\nTodos los emisores son instancias de la clase events.EventEmitter\nPara emitir un evento utiliza emisor.emit(&#39;nombreEvento&#39;, arg, arg,..)\ntantos argumentos como necessitemos (posiblemente ninguno)\n\n\nEn caso de error interno el emisor genera el evento &#39;error&#39;\n\n\nEventos.- Acciones\n\nemisor.on(&#39;nombreEvento&#39;, callback) asocia el callback al evento\nLos argumentos de `emisor.emit(&#39;..&#39;, args) son los parámetros del callback\nCada vez que llega el evento activa la acción\n\n\nemisor.once(&#39;nombreEvento&#39;, callback) asocia el callback al evento     \nactiva sólo una vez, y dá de baja la acción\n\n\npodemos asociar varios callbacks al mismo evento, y ante la llegada del evento se activan en el orden en que se han registrado\nSi no tenemos ninguna acción asociada al evento emisor.on(&#39;error&#39;,..) y llega ese evento, el programa aborta\nUna acción activada se ejecuta inmediatamente (si no estemos ejecutando otra cosa), o se anota en la lista de eventos\n\n\nEventos.- Example\n    const ev = require(&#39;events&#39;)\n    const emisor = new ev.EventEmitter\n    emisor.on(&#39;event&#39;, (i)=&gt;{\n        console.log(&#39;Llega el evento &#39;+i)\n    })\n    emisor.emit(&#39;event&#39;,1)\n    emisor.emit(&#39;event&#39;,2)\n\n", "tags": "", "url": "extra/esdeveniments.html"},
		{"title": "Introducción a NodeJS REPL", "text": "\nIntroducción a NodeJS REPL\n(node shell)\nTSR 2018-19  Juansa Sendra\ninformación completa sobre REPL\n\n\n\nREPL (Read Eval Print Loop)\nEntorno interactivo (node shell) para:\n\nDesarrollar y probar código de forma ágil\nResolver dudas sobre sintaxis/funcionamiento de js\nEjecuta código escrito en cualquier editor\n\n\nDepurar fragmentos de código\nEscribe código en editor, cárgalo en REPL, y trabaja de forma interactiva\n\n\n\nPara seguir este texto necesitas un editor y una terminal\n\n\nREPL\nDesde la consola escribe node\n\nel prompt cambia a &gt;\npodemos evaluar cualquier expresión &gt; 23 + 32\nel sistema lee la expresión (Read), la evalua (Eval), e imprime el resultado (Print), tras lo cual vuelve al principio (Loop)  55 \n&gt;\n\nPara salir pulsa CTRL-C dos veces consecutivas\n\n\nREPL\n&gt; 23 + 32\n55\n&gt; &quot;hola, &quot; + &quot;lector&quot;\n&quot;hola, lector&quot;\n&gt; let x = 10, y = 20\nundefined\n&gt;x+y\n30\n&gt; &quot;otorrinolaringologo&quot;.length\n19\n&gt; [4,2,8,12].includes(6)\nfalse\n&gt;\n\n\nREPL\nSi la expresión a evaluar ocupa varias líneas:\n\nEn cada línea nueva aparece ... (indica que continuamos con la expresión)\n\nVuelve al modo normal cuando finaliza la definición o expresión actual, se ejecuta .break\n\n\n&gt; function suma(a,b) {\n... return a+b\n... }\nundefined\n&gt; suma(10,30)\n40        \n&gt;\n\n\nEjecucion fichero externo\n\nEdita el fichero f.js con cualquier editor\nEjecuta en al consola node f.js\n\n// fichero fact.js\nfunction fact(n) {\n   if (n==1) return 1\n   else {\n      return n*fact(n-1)\n   }\n}\nconsole.log(fact(5))\n\nnode fact.js\n120\n\n\nDepuración con REPL\n-Ejecuta .load f.js desde REPL\n\ncarga y ejecuta el fichero, y se mantiene en el REPL\npuedes probar funciones, inspeccionar variables, etc.\n\n\nDepuración con REPL\n&gt; .load fact.js\n// fichero fact.js\nfunction fact(n) {\n   if (n==1) return 1\n      else {\n            return n*fact(n-1)\n               }\n               }\n               console.log(fact(5))\n120\nundefined\n&gt; fact(0)\nRangeError: Maximum call stack size exceeded\n    at fact (repl:2:14)\n    at fact (repl:5:22)\n    ...\n\n\nDot commands\n\nSon órdenes especiales que empiezan por .\nLas más útiles son\n.help  explica las distintas órdenes dot\n.exit  sale de REPL\n.editor  para escribir expresiones multilínea\n.break  sale del modo editor\n.save fichero  guarda en ese fichero la sesión actual del trabajo (todo lo escrito en REPL)\n.load fichero  carga el fichero en la sesión actual\n\n\n\n\nTambién te interesa saber ...\n\nLas teclas arriba/abajo permiten recorrer la historia de los comandos anteriores\ntab autocompleta expresiones u órdenes\nSi no hay una finalización unica, otro tab muestra las alternativas\nSi no escribimos nada, tab+tab muestra los módulos que node exporta por defecto\nSi x es el nombre de un modulo/objeto, x. tab+tab, muestra sus funciones/propiedades\n\n\n_ representa el resultado de la última expresión\n\n", "tags": "", "url": "extra/nodeREPL.html"},
		{"title": "Patrones de diseño en Sist Distribuidos (S.D.)", "text": "Patrones de diseño en Sist Distribuidos (S.D.)\nTSR 2018-19 Juansa Sendra\nadaptado de &#39;10 common software architecture patterns ...&#39;\n\nIntrodución\n\nLos objetivos al diseñar un S.D. son mejorar escalabilidad y disponibilidad\nPara conseguirlos recurrimos a aplicar replicación y técnicas de tolerancia a fallos\n\n\nPatrón de diseño = Solución sofware reutilizable útil para resolver un problema frecuente\nMuchas propuestas, nos centramos en las indispensables\n\n\n\n\nPatrones de diseño para S.D.\n\nLayered pattern (descomposición por niveles)\nClient/server pattern\nMaster/Slave pattern\nPipe/Filter pattern\nBroker pattern\nPeer-to-Peer pattern\nEvent-Bus pattern\nMVC pattern (modelo/vista/controlador)\nBlackboard pattern\nInterpreter patternLos patrones en negrita se desarrollan en la asignatura\n\n\n\nLayered pattern\n\nDescomposición en subtareas, de forma que:\nCada subtarea (nivel) a $\\neq$ nivel de abstracción\nEl nivel n proporciona servicios al n+1\n\n\nSon frecuentes 4 niveles:\nPresentación (interfaz usuario)\nAplicación (servicio)\nLógica del negocio (dominio)\nAcceso a datos (persistencia)\n\n\nÚtil para aplicaciones de escritorio, e-commerce, ..\n\n\n\n\nCliente/Servidor\n\nUn Servidor, que proporciona servicios bajo demanda a múltiples clientes\nN Clientes, que solicitan servicios al servidor\nSigue un modelo de petición/respuesta sincrónico\nTras responder a un cliente, un servidor atiende (escucha) nuevas peticiones de otros clientes\nEl servidor puede utilizar concurrencia interna para atender de forma simultánea a N clientes&lt;p\n\n\nÚtil para aplicaciones online (e-mail, compartición de documentos, aplicaciones bancarias, ...)\n\n\n\n\n\nCliente/Servidor.- ventajas/inconvenientes\n\nventajas\nBueno para modelar un conjunto de servicios accesibles a los clientes\nSimple si operaciones idempotentes (servidores stateless)\nAmplia difusión\n\n\ninconvenientes\nComplejo si se necesitan servicios con estado\nLos servidores pueden convertirse en puntos de fallo único\n\n\n\n\nMaestro/Esclavo\n\nEl maestro distribuye trabajo entre distintos componentes esclavo equivalentes entre sí\nCada esclavo completa su parte y devuelve el resultado al maestro\nEl maestro computa la respuesta final a partir de los resultados parciales devueltos por los esclavos\nÚtil para:\nescalar tareas que pueden dividirse en fragmentos equivalentes (ej. aplicar una misma tarea sobre fragmentos distintos de los datos)\nreplicación pasiva\n\n\n\n\n\n\nMaestro/esclavo.- ventajas/inconvenientes\n\nventajas\nsimple\nescalable\n\n\ninconvenientes\nSólo aplicable a problemas con posibilidad de descomposición en fragmentos equivalentes e independientes entre sí\nLos esclavos están aislados (no comparten estado)\nLa comunicación maestro/esclavos/maestro puede introducir lantencias\n\n\n\n\nPipe/Filter\n\nSistemas que producen/procesan un flujo de datos\nCada etapa de procesamiento corresponde a un componente Filter\nFilter conectados entre sí mediante tuberías (Pipe)\nlos datos a procesar atraviesan las tuberías\nlas tuberías pueden usarse para buffering y/o sincronización\n\n\nÚtil para compilación distribuida (análisis léxico, parsing, análisis semántico, generación código), workflow en biotecnología, ...\n\n\n\n\nPipe/Filter.- ventajas/inconvenientes\n\nventajas\nmuy flexible. Es fácil añadir/modificar filtros\nFiltros reutilizables, y combinables en distintas configuraciones\nrefleja la concurrencia implícita en los problemas basados en flujos\n\n\ninconvenientes\nEl filtro más lento limita el rendimiento global\nsobrecarga por el desplazmiento de los datos entre filtros\n\n\n\n\nBroker\n\nPatrón usado para estructurar SD con componentes desacoplados\nLos componentes interactúan entre sí mediante invocación de servicios remotos\n\n\nEl componente broker (intermediario) se ocupa de la coordinación/comunicación entre componentes\nLos servidores comunican al broker sus características\nEl cliente solicita los servicios al broker\nEl broker redirecciona cada solicitud al servidor adecuado (ej. equilibrando la carga)\n\n\n\n\n\n\n\nBroker.- ventajas/inconvenientes\n\nventajas\ndistribución transparente al cliente y al desarrollador\npermite transparencia de fallos\nfacilita la contabilidad asociada al uso que hacen los clientes del sistema, proporciona un nivel de aislamiento (seguridad), permite transformar las peticiones según las necesidades del sistema, etc.\n\n\ninconvenientes\nrequiere estandarización de las descripciones de servicios\nsi se añaden políticas de equilibrado de carga y de reconfiguración ante fallos, el broker se complica bastante\nrequiere broker de respaldo para evitar punto de fallo único\n\n\n\n\nPeer-to-Peer\n\nLos componentes (Peers) pueden actuar como:\nclientes (solicitan servicios a otros peers)\nservidores (proporcionan servicios a otros peers)\n\n\nUn Peer puede actuar como cliente, como servidor, o como ambos\ny puede cambiar su rol de forma dinámica\n\n\nSuele ser una red no estructurada, con nodos heterogéneos y volátiles (se conectan/desconectan en momentos impredecibles) \nÚtil para aplicaciones no críticas que requieren replicación masiva (redes de compartición de ficheros, protocolos multimedia como P2PTV, ..) \n\n\n\n\nEvent-Bus\n\nTrata con eventos\nComponentes principales\nfuente (emisor) de eventos.- publica mensajes a canales concretos o a un bus de eventos\noyente (listener) de eventos.- se suscribe a canales concretos (reciben notificaciones ante la llegada de mensajes a esos canales)\ncanales y/o bus de eventos\n\n\nÚtil para servicios de notificación, desarrollo Android, ...\n\n\n\n\n\nEvent-bus.- ventajas/inconvenientes\n\nventajas\nFlexible.- es fácil añadir publicadores, suscriptores y conexiones\nAdecuado para aplicaciones masivamente distribuidas\n\n\ninconvenientes\nEl bus puede convertirse en un cuello de botella\n\n\n\n\nMVC (modelo/vista/controlador)\n\nÚtil para aplicaciones interactivas. Las divide en:\nmodelo.- contiene la funcionalidad y datos básicos\nvista.- muestra la información al usuario (puede definir N vistas sobre un mismo modelo, posiblemente presentando los datos de forma distinta)\ncontrolador.- Gestiona los enventos de entrada del usuario\n\n\nEsta división separa la representación de la información de la forma en que se presenta al usuario\nMayor desacoplamiento $\\rightarrow$ mejor reutilización\n\n\n\n\n\nBlackboard (pizarra)\n\nResulta útil para problemas en los que no se conoce una estrategia de solución determinista\nreconocimiento de formas, identificación y seguimiento de vehículos, identificación de la estructura de proteínas, ...\n\n\nComponentes:\npizarra.- Representa una memoria global estructurada que contiene objetos del espacio de solución\nfuente de conocimiento.- módulos especializados, con su propia representación\nControl.- selecciona, configura y ejecuta módulos\n\n\nTodos los componentes tienen acceso al blackboard\nPueden producir nuevos objetos y añadirlos a la pizarra\nO buscar datos en la pizarra utilizando pattern-matching con la fuente de conocimiento existente\n\n\n\n\n\n\n\nInterpreter pattern\n\nSe utiliza para diseñar un componente qeu interpreta programas escritos en un lenguaje dedicado\nespecifica cómo evaluar las expresiones y sentencias de dicho programa\nla idea básica es disponer de una clase por cada símbolo del lenguaje\n\n\nSe utiliza en lenguajes de interrogación (ej SQL) y lenguajes utilizados para describir protocolos de comunicación \n\n\n\n", "tags": "", "url": "extra/patronesDiseño.html"},
		{"title": "**R**ead", "text": "class: center, middle, inverse\n#Introducción a NodeJS REPL\n.center[## (node shell)]\n.center[enlace a información completa sobre REPL]\n\nlayout: false\n.left-column[## REPL \nRead\nEval\nPrint\nLoop\n.footer[TSR]\n]\n.right-column[\nEntorno interactivo (node shell) para:\n\nDesarrollar y probar código de forma ágil\n\nResuelve dudas sobre sintaxis/funcionamiento de js\n\nEjecuta código escrito en cualquier editor\n\n\n\nDepurar fragmentos de código\n\nEscribe código en editor, cárgalo en REPL, y trabaja de forma interactiva\n\n\n\nPara seguir este texto necesitas un editor y una terminal\n]\n???\n\nNotas para el presentador\n\nCualquier cosa importante\n\n\n\n.left-column[## REPL\n.footer[TSR]\n]\n.right-column[\nDesde la consola escribe node\n\nel prompt cambia a &gt;\n\npodemos evaluar cualquier expresión &gt; 23 + 32\n\nel sistema lee la expresión (Read), la evalua (Eval), e imprime el resultado (Print), tras lo cual vuelve al principio (Loop)  \n55 \n&gt;\n\nPara salir pulsa CTRL-C dos veces consecutivas\n\n&gt; 23 + 32\n55\n&gt; &quot;hola, &quot; + &quot;lector&quot;\n&quot;hola, lector&quot;\n&gt; let x = 10, y = 20\nundefined\n&gt;x+y\n30\n&gt; &quot;otorrinolaringologo&quot;.length\n19\n&gt; [4,2,8,12].includes(6)\nfalse\n&gt;\n]\n.left-column[## REPL\n.footer[TSR]\n]\n.right-column[\nSi la expresión a evaluar ocupa varias líneas:\n\nEn cada línea nueva aparece ... (indica que continuamos con la expresión)\n\nVuelve al modo normal cuando finaliza la definición o expresión actual, se ejecuta .break\n\n\n&gt; function suma(a,b) {\n... return a+b\n... }\nundefined\n&gt; suma(10,30)\n40        \n&gt;\n\n]\n.left-column[## Ejecucion fichero externo\n.footer[TSR]\n]\n.right-column[\n\nEdita el fichero f.js con cualquier editor\n\nEjecuta en la consola node f.js\n\n\n// fichero fact.js\nfunction fact(n) {\n*  if (n==1) return 1\n   else {\n      return n*fact(n-1)\n   }\n}\nconsole.log(fact(5))\nnode fact.js\n120\n]\n.left-column[## Depuración con REPL\n.footer[TSR]\n]\n.right-column[\nEjecuta .load f.js desde REPL\n\ncarga y ejecuta el fichero, y se mantiene en el REPL\n\npuedes probar funciones, inspeccionar variables, etc.\n\n\n&gt; .load fact.js\n// fichero fact.js\nfunction fact(n) {\n   if (n==1) return 1\n      else {\n            return n*fact(n-1)\n               }\n               }\n               console.log(fact(5))\n120\nundefined\n&gt; fact(0)\nRangeError: Maximum call stack size exceeded\n    at fact (repl:2:14)\n    at fact (repl:5:22)\n    ...\n]\n.left-column[## Dot commands\n.footer[TSR]\n]\n.right-column[\n\nSon órdenes especiales que empiezan por .\n\nLas más útiles son\n\n.help  explica las distintas órdenes dot\n\n.exit  sale de REPL\n\n.editor  para escribir expresiones multilínea\n\n.break  sale del modo editor\n\n.save fichero  guarda en ese fichero la sesión actual del trabajo (todo lo escrito en REPL)\n\n.load fichero  carga el fichero en la sesión actual\n]\n\n\n\n\n\n.left-column[## También te interesa saber ...\n.footer[TSR]\n]\n.right-column[\n\nLas teclas arriba/abajo permiten recorrer la historia de los comandos anteriores\n\ntab autocompleta expresiones u órdenes\n\nSi no hay una finalización unica, otro tab muestra las alternativas\n\nSi no escribimos nada, tab+tab muestra los módulos que node exporta por defecto\n\nSi x es el nombre de un modulo/objeto, x. tab+tab, muestra sus funciones/propiedades\n\n_ representa el resultado de la última expresión\n]\n\n\n\n\n", "tags": "", "url": "extra/repl.html"},
		{"title": "Modelo de Sistema Distribuido", "text": "\n\n\nModelo de Sistema Distribuido\n\nModelo = visión abstracta del sistema\nOculta detalles irrelevantes\nSimplifica el razonamiento sobre el sistema\n\n\nDistintas perspectivas (Modelos) \nModelos fundamentales: soluciones a aspectos concretos del SD\nModelo Físico.- componentes (hard+soft) y su interacción\nModelo de Arquitectura.- roles de los componentes y cómo cooperan entre sí\n\n\n\n\nModelos fundamentales\nModelo de Interacción\n\nProcesos que se comunican mediante el intercambio de mensajes \nCanales de comunicación que introducen retardos \nCoordinación inexacta (no existe reloj global) \n\nModelo de Fallos\n\nEspecifica los tipos de fallos que pueden exhibir los procesos y canales de comunicación\nDefine comunicación fiable y procesos correctos\n\n\nModelos fundamentales ...\nModelo de Seguridad\n\nDefine los posibles ataques a procesos y canales de comunicación, y estrategias para resolverlos\n\n\nModelo Físico\n\nDetalla los componentes y su interacción\n\n\n\n\ncaracterística Nodos\nSi la cumplen\nSi no\n\n\n\n\nubicación fija, siempre conectados\nEstáticos\nNo estáticos (mobile computing)\n\n\nno incluidos en otra entidad\nDiscretos\nEmpotrados (internet of things)\n\n\n\nindepedientes entre sí\nAutónomos\nNo autónomos (cluster)\n\n\n\n\nDiscretos (no incluidos en otra entidad física) vs. no discretos (empotrados en otros componentes $\\rightarrow$ Internet of Things – IoT)\nAutónomos (básicamente independientes entre sí) vs. no autónomos (pools de nodos que cooperan para proporcionar un servicio $\\rightarrow$  cloud computing)\n\n\nModelo Físico.- Generaciones\n\n3 generaciones de SD, con distinta escala, uso y características\naños 70-80, escala decenas (LAN)\naños 90, escala miles (inernet)\nactualidad, escala millones (internet of things, bigData, cloud-computing, ubiquiotus-computing)\n\n\n\n\nModelo Físico.- Generaciones ...\n\n\n\nGen\nUso\n\n\n\n\n1\nCompartición de recursos\n\n\n2\ncompartición recursos, servidores escalables y de alta disponibilidad\n\n\n3\ncompartición recursos, servidores escalables y de alta disponibilidad, elasticidad\n\n\n\n\nModelo Físico.- Generaciones ...\n\n\n\nGen\nCaracterísticas\n\n\n\n\n1\nsist. no estardard, uso interno, nodos homogéneos\n\n\n2\nsist. estandard, servicios globales (clientes externos), nodos heterogéneos, QoS (quality of Service)\n\n\n3\n$\\uparrow$ estandards, $\\uparrow$ nodos, $\\uparrow$ técnicas de interconexión, $\\uparrow$ variedad de servicios, $\\uparrow$ clientes, $\\uparrow$ heterogeneidad, QoS\n\n\n\n\nModelo de Arquitectura\n\nDetalla los roles de los componentes, y su mecanismo de interacción\nComponentes = entidades que se comunican (procesos)\n\n\nAcoplamiento fuerte (componentes diseñados para trabajar juntos)\nObjetos distribuidos (ej RMI, CORBA) \n\n\nAcoplamiento débil ($\\uparrow$ autonomía, $\\uparrow$ reutilización)\nServicios Web (ej. SOAP, REST)\nMiddleware de mensajería (ej. JMS, 0MQ)\n\n\n\n\nModelo de Arquitectura: comunicación\n\nDirecta.- Comunicación directa emisor/receptor\nDireccionamiento explícito del receptor\nPrimitivas de paso de mensajes, sockets, RMI\n\n\nIndirecta.- elemento intermedio entre emisor y receptor\nEmisor y receptor desacoplados en espacio y tiempo\nComunicación a grupo (multicast), sistemas de publicación/suscripción o basados en eventos, colas de mensajes, ... \n\n\n\n\nModelo de Arquitectura: Roles y responsabilidades\n\nCliente/servidor (CS).- solicitud/respuesta, asimétrico\nTradicional, habitual, simple, poco escalable\n\n\nPeer to Peer (P2P).- todos los procesos cooperan como iguales\nComplejo (nodos poco fiables), escalable, inseguro \n\n\n\n\nModelo de Arquitectura: niveles\n\nEjemplo.- Wikipedia\n\n¿Qué es?\nEnciclopedia digital escrita de forma cooperativa\nBasada en tecnología wiki\nLenguale de wikitexto editado en el navegador\nPermite enlaces entre páginas (hipervínculos)\n\n\n\n\n\n\nWikipedia.- Modelo de arquitectura\n\nCS\n3 niveles\ninterfaz usuario.- documentos servidos por servidor Apache, y mostrados en el navegador del cliente\naplicación.- logica escrita en PHP\ndatos (persistencia).- usa MySQL\n\n\n\n\nWikipedia.- escalable en tamaño\n\nInicio en 2001\nPocos usuarios\n\n\nEn 2005 ya soporta mucha carga\nEn 2010 la carga es enorme\n5 millones de artículos en inglés, 288 idiomas, 73000 editores, 500 millones de visitantes/mes\nPicos de 24500 accesos/seg, 200GB/s\n\n\n\n\nWikipedia: evolución arquitectura\n\n\n\naño\nsolución\n\n\n\n\n2001\n1 nodo (LAMP = Linux Apache MySQL PHP)\n\n\n2003\nSepara lógica/datos en nodos distintos (SD)\n\n\n2005\nIntroduce proxies inversos (equilibrado de carga, caché de págs frecuentes) y workers $\\rightarrow$ 39 nodos\n\n\n2010\nMantiene la arquitectura, aumenta la cantidad de instancias de cada componente ($&gt;$ 300 nodos). Especializa los servidores Apache según el tipo de aplicación (consultas, gestión de sesión, modif págs)\n\n\n\n\nWikipedia: Arquitectura ... LAMP\n\nEl cliente envía la petición al servidor Apache\nApache redirige la petición al módulo PHP interno\nEl programa PHP envía múltiples peticiones al servidor MySQL\nApache construye un documento web con los resultados y lo remite al cliente\nEl cliente muestra el resultado en el navegador\n\n\nWikipedia: Arquitectura ... LAMP\n\n\nWikipedia: Arquitectura ... Reverse Proxy\nEs un componente de la parte servidor, ubicado entre internet y los servidores web\n\n\n\nAcepta peticiones http, proporciona servicios, y redirige la petición a $\\geq1$ servidores\n\n\n\n\nPunto de entrada único para los clientes (usan el sist sin conocer detalles de los servidores)\n\n\n\nEquilibrado de carga (ej. dirige cada petición al servidor con menos carga)\n\n\n\nSeguridad (autenticación, finalización SSL)\n\n\n\nServidor de contenido estático (caché)\n\n\n\nOtras: ocultación de fallos, compresion, auditoría\n\n\n\n\n\nWikipedia: Arquitectura ... Reverse Proxy\n\n\nWikipedia: Arquitectura 2005\n\n\nWikipedia: Arquitectura 2010\n\n\nEjemplo.- MongoDB\n\n¿Qué es?\nIoT genera gran $\\uparrow\\uparrow$ información (BigData)\n$\\approx$ 40000 millones de sensores generan datos\n\n\n¿Dónde almacenamos los datos?\nUna BD tradicional (relacional) no escala bien\nSe usan alternativas escalables (noSQL)\nUna de ellas es MongoDB\n\n\n\n\n\n\nEj.- Bosh usa MongoBD para su modelo de IoT\n\n\nMongoDB.- Implementación\n\nDivisión horizontal de los datos (sharding)\nEj.- queremos guardar datos sobre todos los estudiantes universitarios\nCada entrada es un objeto con el DNI como identificador, y otros atributos\nDividimos en grupo por tangos de DNI (ej. 00000001 .. 10000000, 10000001 .. 20000000, etc)\n\n\n\n\n\n\nMongoDB.- Implementación ...\n\n3 componentes, con varias instancias de cada uno\nMongos, Servidores de Configuración, Mongod\n\n\n\n\nP2P\n\nCloud Computing\n", "tags": "", "url": "extra/tema10csd.html"},
		{"title": "Tema 1.- Introducción", "text": "\nTema 1.- Introducción\nTecnologías de los Sistemas de Información en la Red\n\n\n\nÍndice\n\nDefinición de Sistema Distribuido\nFormado por distintos nodos interconectados en red\nOfrece imagen de máquina única\n\n\nRelevancia y áreas de aplicación\nEvolución histórica\netapa actual = computación en la nube\n\n\nImplementación servidores\n\n\nConcepto de Sistema Distribuido\n\nConjunto de agentes autónomos. Cada agente;\nes un proceso secuencial con su propio ritmo\ntiene su propio estado independiente\n\n\nLos agentes interactúan (cooperan). Opciones:\nintercambio de mensajes\nmemoria compartida\n\n\nEn la práctica, un sist. distribuido es un sistema en red\n\n\nRelevancia de los Sist. Distribuidos\n\nÁrea  en evolución continua\nEntorno de computación actual distribuido e interconectado (web)\nInfinidad de nodos conectados\nInfinidad de servicios remotos\n\n\n\n\nRama de los sistemas concurrentes\nAsumimos la base proporcionada por CSD\n\n\n\n\nRelevancia ...\n\n:thumbsup: Mejora el rendimiento\nDivide un tarea compleja en subtareas, y asigna cada una a un nodo diferente\n\n\n:thumbsup: Mayor disponibilidad\nSi falla un nodo, otros completan su tarea\n\n\n:thumbsup: Compartición de recursos\nCada nodo tiene recursos asociados (ej.- impresoras, discos)\nOtros nodos del sistema pueden acceder a ellos\n\n\n\n\nRelevancia ...\n\nReto\nconseguir que los ordenadores cooperen entre sí y colectivamente desarrollen trabajo útil\nCrear subsistemas capaces de proporcionar servicios robustos\n\n\nEjemplos a gran escala (millones de usuarios)\nServicio de búsqueda de Google\nCompartición de ficheros en DropBox\nSimulación de fármacos contra el cáncer\n\n\n\n\nPrincipales áreas de aplicación\n\nWorld Wide Web\nredes de sensores\nInternet of things\nComputación cooperativa\nClustes altamente disponibles\nCloud Computing\n\n\nAplicación: WWW\n\nBasada en el modelo Cliente/Servidor\ncliente = navegador web (solicita/recibe documento)\nservidor.- responde a peticiones de docs\n\n\nInicialmente diseñado para compartir documentos\nlos documentos pueden formarse a partir de las respuestas de varios servidores\nPosteriormente extendido para soportar peticiones sobre servicios\n\n\n\n\nAplicación: Redes de Sensores\n\nAparecen equipos de muy bajo coste\nMini-ordenadores de propósito específico\nEmpotrados en disp. de uso cotidiano\nej.- en algunos electrodomésticos\n\n\nContienen sensores (humedad, temperatura, ..)\n\n\nMuchas aplicaciones potenciales\nVigilancia, detección de desastres, monitorización consumo, ...\n\n\n\n\nAplicación: Internet of Things\n\nGeneralización de las redes de sensores\nFacilita la interoperabilidad de los dispositivos\nLos dispositivos pueden interactuar entre sí\nLos dispositivos pueden alterar su entorno\n\n\nNuevos escenarios\nCiudades inteligentes\nAutomatización (construcción, fabricación, ...)\nCuidado médico informatizado\n\n\n\n\nAplicación: Internet of Things\n\n\nAplicación: Comp. Cooperativa\n\nRecursos en internet infrautilizados\nMuchos PCs pasan horas inactivos\nPueden suscribirse para recibir tareas \ninstala soft. cliente, se registra en un servidor \n\n\n\n\nEl servidor \nDivide tarea grande en subtareas\nDistribuye subtareas entre los clientes\nRecopila los resultados\n\n\n\n\nAplicación: Clusters $\\uparrow$ Disponibles\n\nCiertas entornos necesitan $\\uparrow$ disponibilidad\nBancario, Empresarial, Asistencia médica, ...\nDeben garantizar integridad información\nDeben mantener disponibilidad servidores\n\n\n\n\nHechos:\nTodo dispositivo falla en algún momento\nPero fallo simultáneo es muy improbable\n\n\nSolución.- replicación (y reconfiguración tras fallo)\n\n\nAplicación: Cloud Computing (CC)\n\nQueremos construir y facilitar servicios de forma sencilla, eficiente, y económica\nImplantados mediante clusters $\\uparrow$ disponibles\nUn centro de cómputo dedicado es caro\nadquisición, administración, mantenimiento\n\n\nPara $\\downarrow$ costes compartimos centros de cómputo externos (pago por uso)\nAcceso al centro externo a través de internet\nPosible por mejoras en redes y navegadores\n\n\n\n\n\n\nAplic.: CC modelos de servicio\n\nSaaS (software como servicio)\nAplicaciones escalables como servicio\n\n\nPaaS (plataforma como servicio)\nAutomatiza la gestión de servicios elásticos (ciclo de vida, escalabilidad)\n\n\nIaaS (infraestructura como servicio)\nAutomatiza gestión de recursos\nUsa virtualización\n\n\n\n\nImplementación servidor\n\nUn servidor recibe peticiones, las procesa, y retorna respuestas\nPara completar una petición puede necesitar pedir a su vez servicios a otros\nPor escalabilidad, un servidor debería aceptar varias peticiones simultáneas\nMientras gestiona una petición, debe ser capaz de aceptar otras\n\n\nAlternativas para implantar un servidor: servidor concurrente, y servidor asincrónico\n\n\nServidor concurrente (multi-hilo)\n\nCada petición servida por un hilo distinto\nTodos los hilos comparten un estado global\nHay que evitar interferencias e interbloqueos\n\n\n:thumbsup: cada hilo se planifica por separado (si se suspende no afecta al resto del servidor)\n:thumbsdown: control concurrencia $\\rightarrow$ suspensión. Sobrecarga\n:thumbsdown: programación y depuración complejas\nUsado en Java y .NET\n\n\nServidor Asincrónico\n\nprogramación asincrónica = dirigida por eventos\ncorresponde al modelo guarda/acción\nguarda = evento\nacción = callback del evento\n\n\n\n\nmúltiples actividades, pero no acceden de forma concurrente al estado compartido\nLas acciones preparadas para ejecución (cumplen la guarda) se encolan en orden FIFO\n\n\n\n\nServidor Asincrónico ...\n\n:thumbsup: No hay estado compartido: $\\downarrow$ complejidad\n:thumbsup: No soporta threads: $\\downarrow$ sobrecarga $\\uparrow$ escalable\n:thumbsup: El funcionamiento real de un S.D. es dirigido por eventos: facilita razonar sobre el sistema\n:thumbsdown: Toda acción debe cuidar la gestión el estado\n:thumbsdown: No es fácil controlar el orden de encolado\n:thumbsdown: Todo el entorno debe ser asincrónico (ej. servicios del S.O. no bloqueantes)\nUsado en NodeJS y Async .NET\n\n", "tags": "", "url": "extra/tsr01.html"},
		{"title": "Presentació curs 2020-21", "text": "\nPresentació curs 2020-21\nTecnologia dels Sistemas d&#39;Informació en la Xarxa\n####### Juansa Sendra\n\n\n\nÍndex\n\nDades professor i grup\nObjectius assignatura\nEstructura assignatura\nTeoria\nLaboratori\nAvaluació\nBibliografia\n\n\nDades professor i grup\n\nProfessor: Juansa Sendra\nJuan Salvador Sendra Roig (Juansa)\njsendra@dsic.upv.es\nconsultes y tutories baix demanda (email, Teams, despatx 1d44)\n\n\nGrup A\ndocència en Valencià\nCanal de Teams: grupA dins del canal general de TSR\nHorari\nDimecres 8.30-10h\nDivendres 13-14.30h\n\n\n\n\n\n\nObjetius Assignatura\n\nGeneral\nAproximació pragmàtica al disseny i construcció de Sistemes Distribuïts (SD)\n\n\nEspecífics\nEntendre les propietats dels SD\nAdvantatges, àmbit d&#39;aplicació\nInvonvenients, i aspectes a resoldre\nInfluencia de l&#39;estructura del sistema (arquitectura)\n\n\nConeixer les principals tecnologíes i aproximacions\nProgramació asincrònica per a la implantació de components\nMiddleware per a facilitar la cooperació entre components\n\n\nCapacitar per al disseny de l&#39;arquitectura adecuada per a resoldre problemes especifics\nEstudi de examples de sistemes i la seua arquitectura\nÚs de tecnologies rellevants per a la resolució de problemes de laboratori\n\n\n\n\n\n\nEstructura Assignatura\n\nAsignatura amb 6 crédits\nTeoría (1.5 cr)\nPrincipis i propietats generals\n\n\nSeminaris (3 cr)\nTecnologíes básiques, exemples, resolució de problemes\n\n\nLaboratori (1.5 cr)\nImplantació de solucions a problemas senzills\n\n\n\n\n\nTeoria i seminaris s&#39;imparteixen de forma conjunta, i en la resta del text es gasta per a les dos el nom conjunt &quot;Teoria&quot;\n\nTeoría\n\n\n\nTema\ncontingut\nferraments\nsessions\n\n\n\n\nIntroducció\nintro SD, motivació\n\n2\n\n\nNodeJS\njavascript y NodeJS\nNodeJS\n7\n\n\nMiddleware\nMiddleware de mensajería\n0MQ\n6\n\n\nDespliegament\nDespliegue\nDocker\n6\n\n\nRobusteza i fallades\nConsistencia\n\n3\n\n\nEscalabilitat\n\ncluster, MongoDB\n3\n\n\n\n\nLaboratori\n\nProjecte 0 (JavaScript bàsic: des-de la segona setmana). Sense supervisió\njavaScript és diferent a Java\nDiferent model de tipus, suport en execució, etc.\nProgramació funcional\nProgramació conduïda per esdeveniments (servidors asincrónics)\n\n\n\n\n10 sesions supervisades, repartides en tres proyectes\nProxy invers TCP/IP (3 sesions). Utilitza javaScript (JS) y NodeJS (Node)\nAplicacions en NodeJS amb 0MQ (4 sesions) Utilitza JS, Node, 0MQ\nDesplegament (3 sesions). Utilitza JS, Node, Docker\n\n\n\n\nAvaluació\n\n\n\ndata\nprova\ntemari\nformat\npes\nminim\nrecupable\n\n\n\n\n16 novembre\nPrimer parcial\ntemas 1..3 (principi), lab 1\ntest\n3+1 punts\n30%\nsi\n\n\n10 decembre\nLab 2\nlab 2\nresp oberta\n2 punts\n30%\nsi \n\n\n26\nSegon parcial\ntemas 3(final)..6, lab 3\ntest\n3+1 punts\n30%\nsi\n\n\n\n\nRecuperació el 8 febrer\nqualsevol subconjunt de les proves anteriors\nla nota de recuperació preval sobre l&#39;acte original recuperat\n\n\n\n\nBibliografía\n\nCap text es correspon exactament als continguts del curs\n\nMaterial dispers: artícles, llibres, pàgines web (majoritariament en anglés)\ntexts generals de consulta (en anglés i espanyol)\nDistributed Systems: Principles and Paradigms (2nd Ed). Andrew S. Tanenbaum, Maarten van Steen. Prentice Hall 2006\nDistributed Systems: Concepts and Design (5th Ed). George Coulouris, Jean Dollimore, ... Addison-Wesley 2011 \n\n\n\n\nGuíes del alumno per a cada tema\n\nPoden suministrarse referències adicionals en cada tema\n\n", "tags": "", "url": "extra/TSRpresentacion.html"},
		{"title": "Material extra", "text": "Material extra\n\n\n\ntítulo\nhtml\npdf\n\n\n\n\nnodeREPL\nhtml\npdf \n\n\nclausuras\nhtml\npdf \n\n\ncallbacks\nhtml\n\n\n\neventos\nhtml\npdf\n\n\njson\nhtml\n\n\n\nextraJavaScript\nhtml\n\n\n\n\n\n\n\n\npatrones diseño\nhtml\npdf \n\n\n\n", "tags": "", "url": "extra.html"},
		{"title": "Grupo B. Profesor: Juansa Sendra", "text": "Grupo B. Profesor: Juansa Sendra\nEste material es complementario al que puedes encontrr en Poliformat/lessons\nPuedes encontrar versions en html i pdf exclusivas para este grupo (porque considero que mejoran el orden de presentación o facilitan la comprensión de los conceptos). El contenido varía en muchos detalles (por ejemplo en la forma de presentar y explicar los conceptos), pero los conceptos son los mismos que en el material oficial.\nTambién puedes consultar el calendario (plan de trabajo), el mecanismo de evaluación, o las tareas que corresponen en cada momento.\nEl menú de la izquierda proporciona acceso directo a los apartados principales:\n\nHome corresponde a ésta página\n\nPresentación corresponde a la descripción de la asignatura (organización, evaluación, etc.).\n\nLa metodología docente utilizada es la Docencia inversa. Para aclarar cualquier duda relativa a la metodogia puedes consultar esta descripción:\n\nLa docencia inversa requiere cooperación continua entre docente i alumno, así como establecer un plan de trabajo detallado. El apartado Calendario detalla les actividades previas, en el aula, y posterior, correspondientes a cada clase o sesión de prácticas.\n\nEl apartado Teoria introduce el temario y proporciona acceso al conjunto de materials (transparencies, guía del alumno, actividades, ..) para cada uno de los temas.\n\nEl apartado Laboratorio introduce el conjunto de práctiques y proporciona acceso a los materiales (boletín, código base, ..) para cada una de las prácticas.\n\nMaterial extra permite acceder a material adicional de consulta que puede resultar de interés\n\n\nPara aclarar cualquier aspecto relativo al funcionamento del grupo has de contactar conmigo (jsendra@dsic.upv.es) utilitzando email o Teams.\n", "tags": "", "url": "index.html"},
		{"title": "Ejemples JavaScript", "text": "\nEjemples JavaScript\nTecnologia dels Sistemas d&#39;Informació en la Xarxa, Juansa Sendra, Grup A\n\n\n\n0.- Us de funcions, objectes, cláusula this i funció bind()\nconsole.log(&quot;\\n&quot;);\n\nfunction g(){return this.valor;}\n\nvar obj01={ valor:-5*2,\n   fun:function(){\n      var gg=g.bind(this);\n      return gg;\n   }\n}\n\nconsole.log(&quot;obj01.valor:  &quot;,obj01.valor);\nconsole.log(&quot;obj01.fun()():  &quot;,obj01.fun()());\n\nconsole.log(&quot;__________________________________________________________\\n&quot;);\n\nfx1=obj01.fun();\nconsole.log(&quot;fx1():  &quot;,fx1());\n\nvar obj02={ valor:&quot;fun no me referencia&quot;, fun:fx1, fan:g }\n\nconsole.log(&quot;obj02.valor:  &quot;,obj02.valor);        \nconsole.log(&quot;obj02.fun():  &quot;,obj02.fun());\nconsole.log(&quot;obj02.fan():  &quot;,obj02.fan());\n\nconsole.log(&quot;__________________________________________________________\\n&quot;);\n\nobj01.valor=&quot;nuevo valor&quot;;\nconsole.log(&quot;obj01.valor:  &quot;,obj01.valor);\nconsole.log(&quot;obj02.fun():  &quot;,obj02.fun());\nconsole.log(&quot;obj02.fan():  &quot;,obj02.fan());\n\n\n1.- Declaració de variables. Ús de funciones y clausuras\n//Variables\nvar x;\nvar w, ww;\nvar u = Infinity;\n\n//Funciones\nfunction f(y,z){\n   x = function(){ console.log(&quot;función x:      &quot;,y,&quot;     &quot;,z,&quot;    &quot;,u);};\n   w = function(u){ \n         console.log(&quot;función w:      &quot;,y,&quot;     &quot;,z,&quot;   &quot;,u);\n         ww = function(){ console.log(&quot;función ww:     &quot;,y,&quot;     &quot;,z,&quot;   &quot;,u); return y+z+u;};\n       };\n   console.log(`argumentos de f: ${y}  ---  ${z}`);\n}\n\n//Ejecución del código\nf(0,100);\nx();\nw(-1000);\n\nconsole.log(&quot;ww(): &quot; + ww());\n\n//¿Cuál es el resultado de la ejecución de la sentencia console.log(&quot;u= &quot;,u);\n\n\n2.- Clausuras de variables y funciones\nfunction f(y){\n   var x=100;\n   function g(){\n      x++;\n      console.log(&quot;incremento de x:  &quot;+x);\n      return x;\n   }\n   return function(){\n            y++;\n            console.log(&quot;y: &quot; + y);\n            console.log(&quot;y+g(): &quot;,y+g());\n            return y;\n   }\n}\n\nvar z=f(-100);\nz();\nz();\nz();\n\n\n3.- Clausuras de variables y funciones\nvar gety;\n\nfunction main(y){\n   var traza=&quot;inicio&quot;;\n   gety=getY;\n   return f(y);\n\n//   - - - - - - - - - - - - - - - - - - - - - - - - - -\n   function getY(){return y;}\n\n   function f(y){\n      var x=100+y;\n      console.log(&quot;\\ttraza: &quot;, traza);\n\n      if(x%2)return g0; else return g1;\n\n      function g0(){\n         traza += &quot;-g0&quot;; x++;\n         console.log(&quot;g0: incremento de x:  &quot;+x);\n         return f(++y);\n      }\n\n      function g1(){\n         traza += &quot;-g1&quot;; y++;\n         console.log(&quot;g1: incremento de y:  &quot;+y);\n         return f(y);    \n      }\n   }\n}\n\nvar z=main(-100);\nfor(var i=0; i&lt;10;i++) z=z();\n\n//¿Cuál es el resultado de la ejecución de la sentencia console.log(gety())?\n\n\n4.- Uso de operaciones asíncronas\n//operadores asincronas modeladas con la función setTimeout.\n//Note el valor de i asociado a las ejecuciones de las temporizaciones.\n\n\nfor(var i=0; i&lt;10; i++) \n   setTimeout(function(){console.log(i)}, i*1000);\n\n\nconsole.log(&quot;Terminado codigo script  valor actual de i: &quot;,i);\n\n\n5.- Uso de operaciones asíncronas\nfor(var i=0; i&lt;10; i++) \n  setTimeout(function(índice){\n                return function(){console.log(&quot;índice: &quot;,índice)}}(i),\n             i*1000);\n\nconsole.log(&quot;Terminado codigo script  valor actual de i: &quot;,i);\n\n\n6.- Uso de operaciones asíncronas\nlet i = 0;\n\ndo {\n   setTimeout(function(){console.log(i)},i*1000);\n   i++;  \n} while (i&lt;10);\n\nconsole.log(&quot;Terminado codigo script  valor actual de i: &quot;,i);\n\n\n7.- Uso de operaciones asíncronas\nvar i = 0;\n\ndo {\n   let k = i;\n   setTimeout(function(){console.log(k)},k*1000);\n   i++;\n} while (i&lt;10);\n\nconsole.log(&quot;Terminado codigo script&quot;,&quot;   valor actual de i: &quot;,i);\n\n\n8.- Uso de operaciones asíncronas\nfor(let i=0; i&lt;10; i++) \n   setTimeout(function(x){return function(){console.log(x)}}(i),\n              i*1000);\n\n//¿Cuál es el resultado de la ejecución de la sentencia console.log(&quot;i= &quot;,i)?\n\nconsole.log(&quot;Terminado codigo script&quot;);\n\n\n9.- Uso de operaciones asíncronas\nfor(var i=0; i&lt;10; i++) \n  setTimeout(function(índice){return function(){\n                   console.log(&quot;índice:  &quot;,índice,&quot;  i:  &quot;,i)}\n             }(i),\n             i*1000);\n\nconsole.log(&quot;Terminado codigo script&quot;,&quot;   valor actual de i: &quot;,i);\n\n\n10.- Uso de operaciones asíncronas\nfor(var i=0; i&lt;10; i++) \n   setTimeout( function(índice){\n                   console.log(&quot;índice:  &quot;,índice,&quot;  i:  &quot;,i);\n               },\n               i*1000,i)\n\nconsole.log(&quot;Terminado codigo script&quot;,&quot;   valor actual de i: &quot;,i);\n\n\n11.- Uso de operaciones asíncronas\nfor(var i=0; i&lt;10; i++) \n   tempo(i);\n\nconsole.log(&quot;Terminado codigo script&quot;,&quot;   valor actual de i: &quot;,i);\n\nfunction tempo(índice){\n   setTimeout( function(){\n                   console.log(&quot;índice:  &quot;,índice,&quot;  i:  &quot;,i);\n               },\n               índice*1000);\n}\n\n\n12.- Ejercicio (operaciones asíncronas y clausuras)\n\n¿Cuál es el resultado de la ejecución de este código?\n\nfor (var i=0;i&lt;5;i++) \n   (function(){\n       setTimeout( function(){console.log(&quot;---&gt; &quot;,i);}, i*1000 );})();\n\nfor (var k=0;k&lt;3;k++) \n   (function(k){\n       setTimeout( \n         function(){console.log(&quot;==========&gt; &quot;,k);}, k*4010);})(k);\n\nfor (var x=0;x&lt;3;x++){ \n   (function(){\n       var mm=x;\n       setTimeout( function(){\n           var m=x;\n           console.log(&quot;::::::::::::::&gt; &quot;,m,&quot;   &quot;,mm);}, x*8030);\n    })();\n}\n\n\n13.- Operaciones asíncronas paralelizadas (estilo fork-join)\nconsole.log(&quot;Inicio de la operación: &quot;,\nforkJoinAsinc(10,function(){console.log(&quot;\\n\\n\\tFIN de forkJoinAsin&quot;);}),&quot;\\n\\n&quot;);\n\nfunction forkJoinAsinc(numeroInstancias,callback){\n  var continuar=parseInt(numeroInstancias) || -1; if (continuar&lt;0) return false;\n  const num = numeroInstancias; var join = num;\n//FORK -----------------------------\n  for(var i=0; i&lt;num; i++) {\n    let retardo=intRandom(0,10000);\n    setTimeout(function(indice){\n      return function(retardo){\n        console.log(&quot;                   retardo:  &quot;+retardo);\n        if(--join == 0) {\n          console.log(&quot;soy el:  &quot;+indice + &quot;  - - - -&gt;&gt; Y SOY EL ÚLTIMO&quot;);\n//JOIN -----------------------------\n          callback();\n        }\n        else console.log(&quot;soy el:  &quot;+indice + &quot; quedan: &quot; + join + &quot;  - -&gt;&gt; y no soy el último&quot;);\n      }\n    }(i),retardo,retardo);\n  }\n  return true;\n  function intRandom(min, max) {return Math.floor(Math.random() * (max - min)) + min;}\n}\n\n\n14.- Ejecución de varias operaciones asíncronas serializadas\nconsole.log(&quot;Inicio de la operación: &quot;,\nserieAsinc(10,function(){console.log(&quot;\\n\\n\\tFIN de secuenciaAsin&quot;);}),&quot;\\n\\n&quot;);\n\nfunction serieAsinc(numeroInstancias,callback){\n  var continuar=parseInt(numeroInstancias) || -1; if (continuar&lt;0) return false;\n  const num = numeroInstancias; var contador = num;\n//INICIO PROCESAMIENTO SERIE---------------------\n  principal(); return true;  \n//             - - - - - - - - - -\n  function principal(){\n    var xx=num-contador, retardo=intRandom(0,10000);\n    setTimeout(g,retardo);\n\n    function g(){\n      console.log(&quot;----------------&gt;  retardo:  &quot;+retardo);\n      if(--contador == 0) {\n        console.log(&quot;soy el:  &quot;+xx + &quot;  - - - - - -  - - - -&gt;&gt; Y SOY EL ÚLTIMO&quot;);\n//FINAL PROCESAMIENTO SERIE-------------------------------\n        callback();         \n      } else { \n        console.log(&quot;soy el:  &quot;+xx + &quot; quedan: &quot; + contador + &quot;  - -&gt;&gt; y no soy el último&quot;);\n        principal();\n      }\n    }\n  }\n  function intRandom(min,max) {return Math.floor(Math.random() * (max - min)) + min;}\n}\n\n", "tags": "", "url": "lab/lab0ejs.html"},
		{"title": "Laboratorios TSR", "text": "Laboratorios TSR\nEste documento\n\nProporciona instrucciones para que el alumno puede utilizar la infraestructura de los laboratorios DSIC\nIndica aspectos concretos relativos a la asignatura TSR\n\nVirtualización\nPara facilitar la flexibilidad y mantenimiento de los laboratorios, se usan técnicas de virtualización (MV):\n\nEl funcionamiento habitual de los laboratorios se basa en la virtualización de equipos, almacenamiento y redes -&gt; Los alumnos utilizan máquinas virtuales para el desarrollo de sus actividades\nAcceso a las máquinas virtuales\ndesde los equipos alojados en las salas de laboratorio\nmediante conexión remota (sin soporte ni garantia de funcionamiento fuera del horario y calendario docente de los laboratorios)\n\n\n\nTipos de MV\na) Compartida (no necesitamos almacenamiento persistente) -&gt; escritorios virtuales\n- Sesiones sobre equipos virtuales compartidos. Ningún usuario puede modificar características compartidas ni asumir uso exclusivo (ej. uso exclusivo de puertos de comunicación)\n    - Ej sesiones sobre los equipos ubicados en el lab y las sesiones remotas en los servidores &#39;linuxdesktop&#39; y &#39;windesktop&#39;\n- Se complementa con una unidad persistente propia de cada usuario (carpeta DsicoW en Linux, unidad w: en Windows) \n- No mantiene las modificaciones fuera del DiscoW -&gt; el alumno copia manualmente la información que quiera mantener entre el directorio $HOME y DiscoW\n    - excepción.- la carpeta $HOME/myconfig se copia automáticamente a $HOME al inicial sesión\nb) No compartida (equipo individual por alumno -&gt; ej cada alumno puede instalar software específico y configurar del sistema) -&gt; uso exclusivo, estado persistente -&gt; servidores virtuales de portal\n- Las modificaciones se mantienen entre sesiones (estado persistente)\n- Los servidores virtuales con MV individuales, que pueden encontrarse detenidas\n- Para reducir riesgos, estas MV estan separadas de otros recursos (DiscoW, impresoras, directorios de asignaturas, identificación de usuarios, automatización de copias de seguridad, ..) mediante una VPN (red privada virtual) denominada portal\n    - los equipos de portal pertenecen al dominio cloud\n    - para activar una MV detenida existe un servidor portal-ng.dsic.cloud, visible por https desde los equipos con acceso a la VPN del portal\n        - todas las sesiones de escritorio tienen ya establecidad una conexión con la VPN portal (portal es visible desde linuxdesktop y windesktop)\nTSR\nUtiliza MV no compartida (una por alumno) TSR-xx\n\nArrancar MV (desde equipo con acceso a la VPN del portal):\n  1) abrir en un navegador https://portal-ng.dsic.cloud\n  2) Se muestra un aviso del navegador &#39;conexion no segura&#39; -&gt; admitir el certificado no oficial\n  3) Muestra diálogo solicitando nombre de usuario y contraseña -&gt; usar el identificador y password de los labs del DSIC\n  4) Se muestra la lista de nuestras máquinas virtuales. Seleccionamos la que interese (TSR-xx) y si está detenida pulsamos iniciar\n  - NOTA.- pulsando sobre el nombre de la MV nos muestra algunos detalles (ej nombre e IP)\n\nIniciar sesión interactiva remota en modo gráfico\n\nconectar mediante un cliente de escritorio remoto (ej &#39;conexión a escritorio remoto&#39; desde Windows, o &#39;Remmina&#39; en Linux\n\n\nDetener MV.- ejecutar en la MV la orden shutdown -h now\n\nOtros aspectos importantes\na) Contraseña. todas las MV tiene una contraseña inicial para el usuario root. Dicha contraseña se comunicará en su momento, pero debe modificarse cuanto antes (para evitar acceso desde terceros)\n\n\nb) Ports. con la configuración inicial de la MV el cortafuegos impide el acceso desde el exterior a la mayor parte de puertos. Para habilitar un rango de puertos (ej 8000 a 8100) ejecutamos \n   firewall-cms --permanent --add-port=8000-8100/tcp\n   firewall-cmd --reload\nPor economía de recursos, es posible que en una sesión dos estudiantes compartan el mismo equipo (ej una misma máquina virtual remota) -&gt; pueden aparecer interferencias al usar ports. Se recomienda comprobar si hay otros usuarios conectados y pactar las responsabilidades de cada usuario\nc) copia de ficheros\n\nmodo texto (Linux). Usamos shell remoto seguro (ssh)\nmodo texto (Windows). scp archivos root@TSR-xx.dsic.cloud\nmodo grafico (Linux)\n   Lanzar Sistema/conectar con el servidor\n   Ajustar para TSR-xx.dsic.cloud, usuario root, port 22, protocolo ssh\n   Usar ventana de explorador de archivos para trabajar con el sistema de ficheros remoto\n\nBibliografía\n...\n", "tags": "", "url": "lab/labTSR.html"},
		{"title": "Prácticas TSR", "text": "\nPrácticas TSR\nCurso 2020-2021\n\n\n\nObjetivo y herramientas\n\nObjetivo.- Desarrollar y ejecutar componentes NodeJS que se comunican usando ZeroMQ, y desplegarlos mediante Docker para construir un servicio distribuido\n\nHerramientas software\n\nNodeJS, 0MQ, Docker\n\n\n\n\n\n\nPráctica\nNodeJS\n0MQ\nDocker\n\n\n\n\n1\nx\n\n\n\n\n2\nx\nx\n\n\n\n3\nx\nx\nx\n\n\n\n\nInfraestructura para acceso remoto\n\nEscritorio compartido linuxdesktop (sesión sobre un servidor compartido)\nIncluye NodeJS y 0MQ.- útil para las prácticas 1 y 2\nNo soporta uso exclusivo (ej.- ports compartidos por todos los usuarios)\nPara evitar interferencias entre usuarios\nNo permite instalar/eliminar programas, cambiar configuración, ..\nPara guardar vuestro trabajo debéis usar el directorio DiscoW\n\n\n\n\nServidor dedicado (máquina virtual personal)\nMisma configuración que linuxdesktop, y además\nIncorpora Docker (se puede usar para cualquier práctica, incluyendo la 3)\nSe puede modificar y administrar como se quiera (no se comparte)\nLas modificaciones se preservan entre sesiones\n\n\nLas maquinas virtuales dedicadas se acceden con la VPN portal.dsic.cloud\nNo se integran con recursos como DiscoW, impresoras, ..\n\n\n\n\n\n\nEscritorio (sesión) vs máquina dedicada\n\n\n\n\nsesión\nservidor\n\n\n\n\nSistema\nUbuntu 20.04, MATE\nUbuntu 20.04, MATE\n\n\nherramientas\nNodeJs, 0MQ\nNodeJs, 0MQ, Docker\n\n\nacceso a DiscoW\nsi, parte de $HOME\nno\n\n\ninformación fuera de DiscoW\nse pierde\nse mantiene\n\n\nconfiguracion del sistema\nNO modificable\nmodificable\n\n\nconfiguración aplicaciones\nsolo con $HOME\nsi\n\n\ninstalar/desinstalar aplicaciones\nNO\nsi\n\n\nrecursos usados en exclusiva\nNO (ej ports compartidos)\nsi\n\n\nacceso internet\nsi\nsi\n\n\nArrancar/parar servidor\nno\nsi\n\n\n\n\nAlternativas para el alumno\n\nPresencial = uso de las herramientas desde los equipos de los laboratorios de DSIC.- DESCARTADO (covid 19)\n\nSesión remota (escritorio virtual linuxdesktop)\n\nServidor remoto (máquina virtual dedicada)\n\nTodo alumno debe conocer los pasos para usar su máquina virtual dedicada\n\n\nInstalando las herramientas en local\n\nInstalando la máquina virtual en local (sobre virtualBox)\n\nImagen https://filesender.rediris.es/?s=download&amp;amp;token=0c7f6111-4bdf-e152-b001-8d89570557bb \nLa versión actual (tsr-vbox-2021_a.ova) ocupa 5.7GB, expira el 10/12\nAl arrancar autoconecta al usuario user\n\n\n\n\nSesión remota\n\nVPN dsic.upv.es. \nRequiere cliente de escritorio remoto\nselecciona al menos resolucion 1024x768 y 16bpp (bits por pixel)\nMas resolucion y/o colores implica mas trafico de red\nej rdesktop miVirtual -u usuario_remoto -a 16 -g &#39;1024x768&#39;\n\n\n\n\nServidor remoto\n\nVPN dsic.cloud portal-ng\nacceso a https://portal-ng.dsic.cloud\nla URL genera una queja del navegador: acepta el certificiado no oficial y sigue\nIdentifícate en el portal (tulogin/tuclave)\n\n\nArranca máquina virtual (tsr-tulogin-2021.dsic.cloud)\nArranca cliente de escritorio remoto y conecta (o enlace descarga archivo RDP)\nIdentifícate en la maquina virtual (como user/resu o root/GalYMatias)\nSon contraseñas inciales que se recomienda cambiar (orden passwd). \nOJO.- Si olvidas la contraseña de root no podrás administrar la máquina\n\n\n\n\nAl acabar cierra sesión (si no se va a usar en dias, mejor apaga maquina virtual)\nSe puede parar con &quot;shutdown -h now&quot; (recomendable) o desde el portal\n\n\n\n\nUso de ports compartidos en el escritorio remoto\n\nDebemos evitar conflictos al usar ports compartidos\nSi el boletin indica port xxxxN donde N es un dígito (0..9)\nUsa como port 5uuuN, donde uuu son las 3 ultimas cifras de tu DNI\n\n\n\n\nDirectorio $HOME del escritorio remoto\n\nMuchas aplics guardan información personalizada en $HOME\nPero no podemos escribir fuera de DiscoW\nAl iniciar sesion el sistema copia el contenido de DiscoW/myconfig a $HOME\nSi al final de sesión queremos copiar de $HOME a myconfig, hay que hacerlo a mano cp –pR $HOME/.vscode$HOME/DiscoW/myconfig\n\n\n\n\nIntercambio de ficheros con servidor remoto\n\nEn modo texto:\nDesde linux usa ssh\nDesde windows usa git-bash. scp archivos root@miVirtual\n\n\nEn modo grafico (recomendable)\n&quot;sistema/conectar con servidor&quot;, miVirtual, user root, port 22, protocol ssh\nSeguimos a pesar de un aviso &quot;no puedo verificar identidad ..&quot; \nPuedes trabajar sobre el sist de archivos remoto mediante una ventana del explorador de archivos\nSe copia arrastrando archivos\nclick con boton derecho sobre el fondo de la ventana arranca un shell remoto en el servidor de portal\npara iniciar aplicaciones locales que trabajan sobre archivos remotos\n\n\n\n\n\n\n\n\nConfiguracion del cortafuegos en el servidor remoto\n\nej abrir ports 8000-9999 \nfirewall-cmd --permanent -add-port=8000-9999/tcp; firewall-cmd --reload\n\n\n\n", "tags": "", "url": "lab/usoLab.html"},
		{"title": "Prácticas", "text": "Prácticas\ndocumento utilitzación labs TSR\n\n\n\npráctica\nboletín\ncódigo\n\n\n\n\nlab 0 (no asistida)\npart 1, part 2\nejs \n\n\nlab 1\nboletín 1\nfitxers\n\n\nlab 2\nboletín 2, refZMQ\nfitxers\n\n\nlab 3\nboletín 3\nfitxers\n\n\n\n", "tags": "", "url": "practicas.html"},
		{"title": "Presentación curso 2021-22", "text": "\nPresentación curso 2021-22\nTecnología de los Sistemas de Información en la Red, Juansa Sendra, Grupo B\n\n\n\nÍndice\n\nDatos profesor i grupo\nObjetivos asignatura\nEstructura asignatura\nTeoría\nLaboratorio\nEvaluación\nBibliografía\n\n\nDatos profesor y grupo\n\nProfesor: Juan Salvador Sendra Roig (Juansa)\njsendra@dsic.upv.es\nconsultas y tutorías bajo demanda (email, Teams)\n\n\nGrup: B\ndocencia en Castellano\nCanal de Teams: grupB dentro del canal general de TSR\nHorario\nMartes    8.30-10h\nViernes 11.30-13.00h\n\n\n\n\n\n\nObjectivos Asignatura\n\nObjectivo General\nAproximación pragmática al diseño y construcción de Sistemas Distribuidos (SD)\n\n\nObjectivos específicos\nEntender las propietades de los SD\nAdvantatges i àmbit d&#39;aplicació, Inconvenients i aspectes a resoldre\nInfluència de l&#39;estructura del sistema (arquitectura)\n\n\nConeixer les principals tecnologíes i aproximacions\nProgramació asincrònica per a la implantació de components\nMiddleware per a facilitar la cooperació entre components\n\n\nCapacitar per al disseny de l&#39;arquitectura adecuada per a problemes especifics\nEstudi de examples de sistemes i la seua arquitectura\nÚs de tecnologies rellevants per a la resolució de problemes de laboratori\n\n\n\n\n\n\nEstructura Asignatura\n\nAsignatura de 6 créditos\nTeoría (1.5 cr)\nPrincipios i propiedades generales\n\n\nSeminarios (3 cr)\nTecnologías básicas, ejemplos, resolución de problemas\n\n\nLaboratorio (1.5 cr)\nImplantación de soluciones a problemas sencillos\n\n\n\n\n\nTeoría y seminarios se imparten de forma conjunta: en el resto del texto se utilizas para ambos el nombre &quot;Teoria&quot;\n\nTeoría\n\n\n\nTema\ncontenido\nherramientas\nsesiones\n\n\n\n\n1- Introducción\nintro SD, motivación\n\n2\n\n\n2- NodeJS\njavascript y NodeJS\nNodeJS\n7\n\n\n3- Middleware\nMiddleware de mensajería\n0MQ\n6\n\n\n4- Despliegue\nDespliegue\nDocker\n6\n\n\n5- Gestió de fallos\nConsistència\n\n3\n\n\n6- Escalabilidad\nEscalabilidad\ncluster, MongoDB\n3\n\n\n\n\nLaboratorio\n\nProyecto 0 (JavaScript básico: desde la segunda semana). Sin supervisión\njavaScript es distinto a Java\nDiferente model de tipus, soporte en ejecución, etc.\nProgramación funcional\nProgramación dirigida por eventos (servidores asincrónicos)\n\n\n\n\n10 sesiones supervisadas, repartidas en tres proyectos\nProxy inverso TCP/IP (3 sesiones). Utilita javaScript (JS) y NodeJS (Node)\nAplicaciones en NodeJS y 0MQ (4 sesions) Utiliza JS, Node, 0MQ\nDespliegue (3 sesions). Utiliza JS, Node, Docker\n\n\n\n\nEvaluación\n\n\n\nfecha\nprueba\ntemario\nformato\npuntos\nminimo\nrecup\n\n\n\n\n28 octubre\nParcial 1\ntemas 1..3(principio), lab 1\ntest\n3+1\n30%\nsi\n\n\n??\nLab 2\nlab 2\nresp abierta\n2\n30%\nsi \n\n\n??\nParcial 2\ntemas 3(final)..6, lab 3\ntest\n3+1\n30%\nsi\n\n\n\n\nRecuperación el ??\nCualquier subconjunto de las pruebas anteriores\nLa nota de recuperación prevalece sobre el acto original recuperado\n\n\n\n\nBibliografía\n\nNo hay ningún texto que se corresponda exactament con los contenidos del curso\n\nMaterial disperso: artículos, libros, páginas web (mayoritariamente en inglés). Indicado en cada tema\ntextos generales de consulta (en inglés y español)\nDistributed Systems: Principles and Paradigms (2nd Ed). Andrew S. Tanenbaum, Maarten van Steen. Prentice Hall 2006\nDistributed Systems: Concepts and Design (5th Ed). George Coulouris, Jean Dollimore, ... Addison-Wesley 2011 \n\n\n\n\nGuías del alumno para cada tema, y otro material adicional accesible en Poliformat\n\n\n", "tags": "", "url": "presentacion.html"},
		{"title": "sesión 1.1", "text": "sesión 1.1\nResultados de aprendizaje\n\nIdentificar los motivos por los cuales los Sistemas Distribuidos (SD) son relevantes\nIdentificar algunas áreas de aplicación de los SD \n\nTrabajo\n\n\n\n\n\n\n\n\nPrevio\nvideo &quot;Areas de aplicación de los SD&quot; (14 mins): video, transparencias html pdf \n\n\n\nCuestionario Poliformat &quot;Tema 1.- Arees d&#39;aplicació dels SD&quot; (15 minuts)\n\n\n\nEn el aula\nBoletín de actividades tema 1 \n\n\nPosterior\nCuestiones propuestas en las transparencias &quot;Areas de aplicación de los SD&quot; (15 mins) \n\n\n\nNotas\n\nEn pararelo al Tema 1 debemos empezar a estudiar los aspectos básicos de JavaScript (JS), discutidos en la pràctica 0. A lo largo de las tres primersas semanas el alumno debe trabajar la práctica 0 en casa.\n\n", "tags": "", "url": "sesion/1.1.html"},
		{"title": "sessió 1.2", "text": "sessió 1.2\nResultats d&#39;aprenentatge\n\nIdentificar les etapes principals en la evolució del serveis software \nIdentificar els principals models de serveis en el núvol \nIdentificar els dos paradigmes de programació en el servidor \n\nTreball\n\n\n\n\n\n\n\n\nPrevi\n&quot;Evolució dels serveis software&quot; video (12 min), transparències html pdf \n\n\n\nCuestionari poliformat &quot;Tema 1.- serveis software y models de programació: test preliminar&quot; (15 minuts) \n\n\n\n&quot;Servidors escalables&quot; video (8 min.), transparències html pdf  \n\n\nEn el aula\nActivitats 2 i 3 del bulletí del tema 1 (50 minuts) \n\n\n\nActivitat 4  del bulletí del tema 1 (30 minuts)\n\n\nPosterior\n\n\n\nNotes\nEn pararel al Tema 1 hem de començar a estudiar els aspectes bàsics de JavaScript (JS), discutits en la pràctica 0. Al llarg de les tres primeres setmanes l&#39;alumne ha de treballar la pràctica 0 a casa. \n", "tags": "", "url": "sesion/1.2.html"},
		{"title": "sessió 1.3", "text": "sessió 1.3\nResultats d&#39;aprenentatge\n\n\n\n\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\nvideo (8 min.), transparències html pdf \n\n\n\nCuestionari poliformat &quot;&quot; (15 minuts) \n\n\nEn el aula\nActivitats 2 i 3 del bulletí del tema 1 (50 minuts) \n\n\n\nActivitat 4  del bulletí del tema 1 (30 minuts)\n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/1.3.html"},
		{"title": "sesión 2.1", "text": "sesión 2.1\nResultados de aprendizaje\n\nEscribir correctamente programas JavaScript sencillos.\nDeclarar  variables  de  manera adecuada en programas JavaScript.\n\nTrabajo\n\n\n\n\n\n\n\n\nPrevio\nRevisar i resolver la primera parte de la Práctica 0 (80 min)\n\n\n\nVideo &quot;JavaScript: ámbito variables&quot; (11 minutos): video videoSol, transparències)\n\n\n\nRevisar apartado 8 de la presentación de la práctica 0 (15 mins)\n\n\n\nCuestionari Poliformat &quot;Tema 2. Ámbito&quot; (15 min)\n\n\nEn aula\nExperimentar funcionamiento REPL (html (15 min) pdf)\n\n\n\nResolver dudas sobre actividades práctica 0 (30 min)\n\n\n\nActividad 1 (y opcionalmente la 2) del tema 2 (30 min)\n\n\nPosterior\nComprobar funcionamiento de los ejemplos de la práctica 0 (30 min)\n\n\n\nNotas\n", "tags": "", "url": "sesion/2.1.html"},
		{"title": "sesión 2.2", "text": "sesión 2.2\nResultados de aprendizaje\n\nRepasar programación funcional\nfirst-class functions, higher-order functions y aplicaciones\nclausuras y aplicaciones\n\nTrabajo\n\n\n\n\n\n\n\n\nPrevio\n&quot;Invocación funciones&quot; video (12 minuts) \n\n\n\nLeer la hoja resumen e intentar los ejercicios\n\n\nEn el aula\nRevisar/aclarar las dudas sobre prog Funcional\n\n\nCorregir y completar los ejercicios de la parte previa\n\n\nPosterior\n\n\n\nNotas\n", "tags": "", "url": "sesion/2.2.html"},
		{"title": "sesión 2.3", "text": "sesión 2.3\nResultados de aprendizaje\n\nProg. Funcional\nGestión de eventos\n\nTrabajo\n\n\n\n\n\n\n\n\nPrevio\nEventos: leer transparencias en material extra html pdf (10 min) \n\n\n\nActividad 2 del boletín del tema 2 (20 min)\n\n\nEn el aula\nActividades sobre prog. funcional (60 min). Resultado Tarea del día anterior\n\n\n\nAnálisis actividad 2 del boletín del tema 2 (30 minuts)\n\n\nPosterior\n\n\n\nNotas\n", "tags": "", "url": "sesion/2.3.html"},
		{"title": "sesión 2.4", "text": "sesión 2.4\nResultdos de aprendizaje\n\nFijar conceptos mediante el desarrollo de actividades\n\nTrabajo\n\n\n\n\n\n\n\n\nPrevio\nEjercicios 3 i 6 de las actividades del tema 2 (30 min)\n\n\n\n\n\nEn el aula\nExplicación detallada actividad 2 (eventos)\n\n\n\nrepaso transparencias javascript, resolución actividades 3 i 6 \n\n\n\ndel boletín del tema 2\n\n\nPosterior\n\n\n\nNotas\n", "tags": "", "url": "sesion/2.4.html"},
		{"title": "sesión 2.5", "text": "sesión 2.5\nResultados de aprendizaje\n\nComprender la estructura de NodeJS y las principales aplicaciones  \nPresentar los módulos de nodeJS que utilizaremo en el laboratorio\n\nTrabajo\n\n\n\n\n\n\n\n\nPrevio\nVideo &quot;NodeJS-part1&quot; (14 mins)\n\n\n\nVideo &quot;NodeJS-part2&quot; (9 mins)\n\n\n\ntransparencias videos html pdf\n\n\nEn el aula\nCompletar Actividades 3 i 6 del boletín del tema 2 \n\n\n\nTrabajar los ejemplos de uso de módulos JS presentados en los vídeos\n\n\nPosterior\n\n\n\nNotas\n", "tags": "", "url": "sesion/2.5.html"},
		{"title": "sessió 2.6", "text": "sessió 2.6\nResultats d&#39;aprenentatge\n\nReforzar la comprensió del modul net (exercicis)\nAfianzar el domini de JavaScript\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\nAltres aspectes de Javascript. Video part 1 (15 minuts), Video part 2 (4 minuts),  transparències html \n\n\n\nCuestionari poliformat &quot;Tema 2, modulo net&quot; (autoevaluación) \n\n\nEn el aula\nActivitat 6  del bulletí del tema 2\n\n\n\nResolució dubtes vídeo &quot;altres aspectes de JavaScript&quot;\n\n\n\nModificacions exemples .net\n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/2.6.html"},
		{"title": "sessió 2.7", "text": "sessió 2.7\nResultats d&#39;aprenentatge\n\nAfianzar els conceptes de JavaScript\nTreballar de manera més especifica els moduls net i http de NodeJS\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\nRepasar material del tema 2 per a poder plantejar dubtes (35 min) \n\n\nEn el aula\nResoldre dubtes (30 min)\n\n\n\nActivitat 1 del següent document pdf (60 min)\n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/2.7.html"},
		{"title": "sessió 3.1", "text": "sessió 3.1\nResultats d&#39;aprenentatge\n\nRecordar el concepte de Middleware i la seua importància per a controlar la complexitat al desenvolupar sistemes distribuïts\nCentrar la discusió en els Middleware Orientats a Missatgeria\nIntroduir 0MQ com a middleware orientat a missatgeria\nDetallar els passos per abordar un problema utilitzant 0MQ+NodeJS\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\nVideo zmq (15 minuts)\n\n\n\nvideo pasos per abordar un problema amb zmq (15 minuts)\n\n\n\nVideo example: zmq+nodeJS (12 minuts)\n\n\n\ntransparències del videos pdf \n\n\nEn el aula\nPatrons de diseny (30 min)\n\n\n\nAplicació example (xat) (60 min)\n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/3.1.html"},
		{"title": "sessió 3.2", "text": "sessió 3.2\nResultats d&#39;aprenentatge\n\nAplicació dels sockets req/rep per a implantar el patró client/servidor\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\nRevisar els videos de la sessió anterior (introducció a 0MQ)\n\n\nEn el aula\nTreballar el patró client/servidor (conexions 1:1, 1:n, n:1) (transparències html)\n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/3.2.html"},
		{"title": "sessió 3.3", "text": "sessió 3.3\nResultats d&#39;aprenentatge\n\nIntroduir el patró pipeline\nIntroduir el patró difussió\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\nVideo patró pipeline (13 minuts)\n\n\n\nVideo patró difussió (10 minuts)\n\n\n\ntransparències corresponents als videos html \n\n\nEn el aula\nActivitat 1 del tema 3 (sense ampliació)\n\n\n\nTasca 2.1 butlletí pràctica 2 (publicador rotatori)\n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/3.3.html"},
		{"title": "sessió 3.4", "text": "sessió 3.4\nResultats d&#39;aprenentatge\n\nIntroduir els sockets tipus Router i Dealer\nIntroduir el patró broker/workers\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\nVideo sockets router/dealer (8 minuts)\n\n\n\nVideo patró broker/workers 1a part (12 minuts)\n\n\n\nVideo patró broker/workers 2a part (15 minuts)\n\n\n\ntransparències corresponents als videos html \n\n\nEn el aula\nActivitat 1 del tema 3 (la part &#39;ampliació&#39;)\n\n\n\nActivitat 4 del tema 3\n\n\n\nActivitat 7 del tema 3\n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/3.4.html"},
		{"title": "sessió 3.5", "text": "sessió 3.5\nResultats d&#39;aprenentatge\nResultats d&#39;aprenentatge\n\nIntroduir els sockets tipus Router i Dealer\nIntroduir el patró broker/workers\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\nVideo sockets router/dealer (8 minuts)\n\n\n\nVideo patró broker/workers 1a part (12 minuts)\n\n\n\nVideo patró broker/workers 2a part (15 minuts)\n\n\n\ntransparències corresponents als videos html \n\n\nEn el aula\nActivitat 1 del tema 3 (la part &#39;ampliació&#39;)\n\n\n\nActivitat 4 del tema 3\n\n\n\nActivitat 7 del tema 3\n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/3.5.html"},
		{"title": "sessió 3.6", "text": "sessió 3.6\nResultats d&#39;aprenentatge\nResultats d&#39;aprenentatge\n\nIntroduir els sockets tipus Router i Dealer\nIntroduir el patró broker/workers\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\nVideo sockets router/dealer (8 minuts)\n\n\n\nVideo patró broker/workers 1a part (12 minuts)\n\n\n\nVideo patró broker/workers 2a part (15 minuts)\n\n\n\ntransparències corresponents als videos html \n\n\nEn el aula\nActivitat 1 del tema 3 (la part &#39;ampliació&#39;)\n\n\n\nActivitat 4 del tema 3\n\n\n\nActivitat 7 del tema 3\n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/3.6.html"},
		{"title": "sessió 4.1", "text": "sessió 4.1\nResultats d&#39;aprenentatge\n\nIntroduir el concepte de desplegament\nDemostrar la necessitat de automatitzar el desplegament\nIntroduir el concepte de contenidor\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\n\n\nEn el aula\nTransparències introducció (concepte desplegament, necessitat automatització, concepte de contenidor html\n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/4.1.html"},
		{"title": "sessió 4.2", "text": "sessió 4.2\nResultats d&#39;aprenentatge\n\nReforçar el concepte de desplegament i la necessitat d&#39;automatització\nIntroduir Docker per a gestió de conenidors\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\n\n\nEn el aula\nRepàs del concepte de desplegament, Introducció a Docker (videos 2 i 3 de desplegament) \n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/4.2.html"},
		{"title": "sessió 4.3", "text": "sessió 4.3\nResultats d&#39;aprenentatge\n\nConceptes bàsics de Docker: imatge, contenidor, depósit\nEntendre la construccio d&#39;un entorn de proves: varios components en la mateixa màquina\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\nVideos 4 i 5 de desplegament (pots trobarlos en la secció de teoria)\n\n\nEn el aula\nComentar el contingut dels videos 4 i 5, reforçar conceptes\n\n\n\nDependre a constuir un entorn de proves (varios components en la mateixa màquina), tant en el modo manual com automatitzat\n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/4.3.html"},
		{"title": "sessió 4.4", "text": "sessió 4.4\nResultats d&#39;aprenentatge\n\n\n\n\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\nVideo &quot;&quot; (12 minuts): video, transparències html pdf \n\n\n\nCuestionari poliformat &quot;&quot; (15 minuts) \n\n\nEn el aula\nActivitats 2 i 3 del bulletí del tema 1 (50 minuts) \n\n\n\nActivitat 4  del bulletí del tema 1 (30 minuts)\n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/4.4.html"},
		{"title": "sessió 4.5", "text": "sessió 4.5\nResultats d&#39;aprenentatge\n\n\n\n\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\nVideo &quot;&quot; (12 minuts): video, transparències html pdf \n\n\n\nCuestionari poliformat &quot;&quot; (15 minuts) \n\n\nEn el aula\nActivitats 2 i 3 del bulletí del tema 1 (50 minuts) \n\n\n\nActivitat 4  del bulletí del tema 1 (30 minuts)\n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/4.5.html"},
		{"title": "sessió 4.6", "text": "sessió 4.6\nResultats d&#39;aprenentatge\n\n\n\n\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\nVideo &quot;&quot; (12 minuts): video, transparències html pdf \n\n\n\nCuestionari poliformat &quot;&quot; (15 minuts) \n\n\nEn el aula\nActivitats 2 i 3 del bulletí del tema 1 (50 minuts) \n\n\n\nActivitat 4  del bulletí del tema 1 (30 minuts)\n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/4.6.html"},
		{"title": "sessió 5.1", "text": "sessió 5.1\nResultats d&#39;aprenentatge\n\nConceptes de defecte, error i fallada \nUtilitats de la replicació\nModels de replicació: advantatjes e inconvenients\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\n\n\nEn el aula\nTreballem la primera part del tema (transparències 1..17)\n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/5.1.html"},
		{"title": "sessió 5.2", "text": "sessió 5.2\nResultats d&#39;aprenentatge\n\nRepasar la replicació passiva\nEntendre que existeixen diferents alternatives de propagació, amb diferents característiques (models de consistència)\nDetallar els diferents models de consistència\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\n\n\nEn el aula\nResta de tema (transparències 18 ..)\n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/5.2.html"},
		{"title": "sessió 5.3", "text": "sessió 5.3\nResultats d&#39;aprenentatge\n\nPràctica anàlisi traçes per a determinar el model de concurrència\nExample consistència final\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\n\n\nEn el aula\nActivitats del bulletí del tema 5\n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/5.3.html"},
		{"title": "sessió 6.1", "text": "sessió 6.1\nResultats d&#39;aprenentatge\n\nConeixer el concepte de escalabilitat i els mecanismes bàsics per a obtindre un sistema escalable\nTeorema CAP (aplicable en sistemes d&#39;àmbit global)\nReplicació multi-màster\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\n\n\nEn el aula\nTreballem la primera part del tema (transparències 1..19)\n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/6.1.html"},
		{"title": "sessió 6.2", "text": "sessió 6.2\nResultats d&#39;aprenentatge\n\nExamples d&#39;escalabilitat: multiprocessador i multicomputador\nEscalabilitat del nivell de dades\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\n\n\nEn el aula\nResta del tema \n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/6.2.html"},
		{"title": "sessió 6.3", "text": "sessió 6.3\nResultats d&#39;aprenentatge\n\nAfiançar els conceptes a partir de les activitats del tema\n\nTreball\n\n\n\n\n\n\n\n\nPrevi\n\n\nEn el aula\nActivitats del tema 6 \n\n\nPosterior\n\n\n\nNotes\n", "tags": "", "url": "sesion/6.3.html"},
		{"title": "Declaración y ámbito de las variables en Javascript", "text": "\nDeclaración y ámbito de las variables en Javascript\nTSR 2021. Grupo B, Juansa Sendra\n\n\n\nUtilización correcta de la declaración de variables en JS\nVarías alternativas. ¿diferencias?\n\ndeclaración const        const x = ..Inicialización obligatoria. No puede reasignarse\ndeclaración implicita    x = ..      Inicialización obligatoria. NO UTILIZAR\ndeclaración var        var x = ..  Inicialización opcional\ndeclaración let        let x = ..  Inicialización opcional. UTILIZAR\n\nDiferencias\n\nLa declaración const x introduce una constante, el resto variables\nLa declaración implícita, let y var se diferèncien en el ámbito de declaración de x\nexcepto en var, no podemos redeclarar en el mismo ámbito\n\n\n\n\nÁmbito de las variables\n\námbito de x $\\rightarrow$ desde qué posiciones del código tenemos acceso a x\nLos ámbitos son anidables, y busca desde dentro hacia afuera\n\nSi encontramos x en un nivel, enmascara declaraciones de x en ámbitos más externos\nEn un punto P del programa son accesibles las variables definidas en todos los ámbitos que incluyen P \n\n\nEl ámbito puede ser:\nLocal al bloque = fragmento de código entre {..} o instrucción (ej. bucle for) (let) (desde el punto de declaración hasta el final del bloque)\nLocal a la función (var) (toda la función donde se define)\nGlobal (implicita, o var/let fuera de ninguna función o block)\n\n\n\n\n\n\nEjemplo 1\nPartimos de este ejemplo, y vamos creando otros en base a modificaciones menores. Trata de averiguar el resultado en cada caso. La solución al final\n`js {1,2,4-5}\nlongFunc()\nfunction longFunc() {\n    console.log(x)\n    var x = &#39;A short text &#39; + x\n    for (i=1; i&lt;=10; i++) {\n        console.log(&#39;10 x &#39;+i +&#39; = &#39;+ i*10)\n    }\n    console.log(&#39;The final value of &quot;i&quot; is &#39; + i)\n}\n// console.log(x)\n// console.log(i)\n\n---\n## Ejemplo 2\n```javascript\nlongFunc()\n\nfunction longFunc() {\n    console.log(x)\n    x = &#39;A short text &#39; + x        // x implicita\n    for (i=1; i&lt;=10; i++) {\n        console.log(&#39;10 x &#39;+i +&#39; = &#39;+ i*10)\n    }\n    console.log(&#39;The final value of &quot;i&quot; is &#39; + i)\n}\n\n// console.log(x)\n// console.log(i)\n\nEjemplo 3\nlongFunc()\n\nfunction longFunc() {\n    var x=0 //***\n    console.log(x)\n    x = &#39;A short text &#39; + x\n    for (i=1; i&lt;=10; i++) {\n        console.log(&#39;10 x &#39;+i +&#39; = &#39;+ i*10)\n    }\n    console.log(&#39;The final value of &quot;i&quot; is &#39; + i)\n}\n\n// console.log(x)\n// console.log(i)\n\n\nEjemplo 4\nlongFunc()\n\nfunction longFunc() {\n    var x=0\n    console.log(x)\n    x = &#39;A short text &#39; + x\n    for (i=1; i&lt;=10; i++) {\n        console.log(&#39;10 x &#39;+i +&#39; = &#39;+ i*10)\n    }\n    console.log(&#39;The final value of &quot;i&quot; is &#39; + i)\n}\n\nconsole.log(x)        //****\n// console.log(i)\n\n\nEjemplo 5\nlongFunc()\n\nfunction longFunc() {\n    var x=0 //***\n    console.log(x)\n    x = &#39;A short text &#39; + x\n    for (i=1; i&lt;=10; i++) {\n        console.log(&#39;10 x &#39;+i +&#39; = &#39;+ i*10)\n    }\n    console.log(&#39;The final value of &quot;i&quot; is &#39; + i)\n}\n\n// console.log(x) //****\n console.log(i)    //****\n\n\nEjemplo 6\nlongFunc()\n\nfunction longFunc() {\n    var x=0\n    console.log(x)\n    let x = &#39;A short text &#39; + x        //***\n    for (i=1; i&lt;=10; i++) {\n        console.log(&#39;10 x &#39;+i +&#39; = &#39;+ i*10)\n    }\n    console.log(&#39;The final value of &quot;i&quot; is &#39; + i)\n}\n\n// console.log(x)\n// console.log(i)\n\n\nEjemplo 7\nlongFunc()\n\nfunction longFunc() {\n    var x=0\n    console.log(x)\n    x = &#39;A short text &#39; + x\n    for (i=1; i&lt;=10; i++) {\n        console.log(&#39;10 x &#39;+i +&#39; = &#39;+ i*10)\n    }\n    console.log(&#39;The final value of &quot;i&quot; is &#39; + i)\n}\n\n// console.log(x)\n// console.log(i)\n\n\nEjemplo 8\nlongFunc()\n\nfunction longFunc() {\n    var x=0\n    console.log(x)\n    x = &#39;A short text &#39; + x\n    for (i=1; i&lt;=10; i++) {\n        console.log(&#39;10 x &#39;+i +&#39; = &#39;+ i*10)\n    }\n    console.log(&#39;The final value of &quot;i&quot; is &#39; + i)\n}\n\n// console.log(x)\nconsole.log(i)  //****\n\n\nEjemplo 9\nlongFunc()\n\nfunction longFunc() {\n    var x=0\n    console.log(x)\n    let x = &#39;A short text &#39; + x        \n    for (var i=1; i&lt;=10; i++) {    //****\n        console.log(&#39;10 x &#39;+i +&#39; = &#39;+ i*10)\n    }\n    console.log(&#39;The final value of &quot;i&quot; is &#39; + i)\n}\n\n// console.log(x)\nconsole.log(i)\n\n\nEjemplo 10\nlongFunc()\n\nfunction longFunc() {\n    var x=0\n    console.log(x)\n    let x = &#39;A short text &#39; + x\n    for (let i=1; i&lt;=10; i++) {  //****\n        console.log(&#39;10 x &#39;+i +&#39; = &#39;+ i*10)\n    }\n    console.log(&#39;The final value of &quot;i&quot; is &#39; + i)\n}\n\n// console.log(x)\n// console.log(i) //****\n\n\nEjemplo 11\n`javascript class:&quot;LineNo&quot;\nlongFunc()\nfunction longFunc() {\n    var x=0\n    let i    //\n    console.log(x)\n    x = &#39;A short text &#39; + x\n    for (i=1; i&lt;=10; i++) {    //\n        console.log(&#39;10 x &#39;+i +&#39; = &#39;+ i*10)\n    }\n    console.log(&#39;The final value of &quot;i&quot; is &#39; + i)\n}\n// console.log(x)\n// console.log(i)\n`\n\nResumen\n\nEjemplo 1.- No error, pero console.log(x) dentro de longFunc muestra &#39;undefined&#39;\nEjemplo 2.- Error. Linea 4, x not defined\nEjemplo 3.- ok\nEjemplo 4.- Error. Linea 13, x not defined\nEjemplo 5.- ok\nEjemplo 6.- Error. Linea 6, x has already been declared\nEjemplo 7.- ok\nEjemplo 8.- ok\nEjemplo 9.- Error. Linea 14, y not defined\nEjemplo 10.- Error. Linea 10, y is not defined\nEjemplo 11.- ok\n\n", "tags": "", "url": "sesion/ambitVars/ambitVars.html"},
		{"title": "Áreas de Aplicación de los Sistemas Distribuidos", "text": "\nÁreas de Aplicación de los Sistemas Distribuidos\nTSR 2021 Grupo B. Juansa Sendra\n\n\nEntorno de computación actual $\\rightarrow$ distribuido e interconectado\n\nInfinidad de dispositivos interconectados (PCs, portátiles, tabletas, móviles, ...)\nQue soportan de manera nativa estandards universales.- ethernet, ip, http, html, ...\n\nLa idea es aprovechar ese contexto para:\n\nOfrecer/consumir servicios remotos y robustos\nrobustos $\\rightarrow$ toleran fallos (alta disponibilidad) y son escalables\nbuscadores, almacenamiento (persistencia), redes sociales, aplicaciones online, ...\n\n\nExplotar la cooperación entre dispositivos para resolver problemas complejos\nej. sustituir super-ordenadores por la cooperación de varios dispositivos económicos y/o pre-existentes\n\n\nDesarrollar nuevos escenarios (nueva funcionalidad)\nej. utilizar Mots = ordenadores económicos que pueden incrustarse en otros dispositivos (electrodomésticos, vehículos, etc.)\n\n\n\n\nInfraestructura actual.- WWW\n\nSolicitud/respuesta $\\rightarrow$ Cliente/Servidor\ncliente = usuario que interactúa (pide documentos) mediante un navegador\n\n\nCompartición de documentos (documentos estáticos)\n\n\n\nSimple.- stateless (servidores sin estado)\nPotente.- cada documento mantiene enlaces a otros documentos\nLas partes enlazadas pueden residir en servidores diferentes\n\n\n\n\n1.- Servicios robustos\nWWW + el usuario no solicita documentos, sino servicios:\n\nLa solicitud incluye la funcionalidad deseada y los argumentos correspondientes (ej.- queremos obtener el mapa que corresponde a unas coordenadas y escala)\nEl servidor ejecuta la lógica de aplicación, y calcula la resposta (respuesta dinámica)\nEl servidor puede modificar su estado en respuesta a solicitudes cliente\nLa respuesta del servidor corresponde al resultado de la solicitud de servicio\n\n\n\n1.- Servicios robustos: Disponibilidad\n\nEl servicio ha de estar siempre disponible \nQueremos que tolere fallos $\\rightarrow$ requiere replicación\nQueremos evitar el siguiente escenario\n\n\n\n\n\n1.- Servicios robustos: Escalabilidad\n\nEl servicio ha de ser escalable\nHa de ser capaz de adaptarse a una carga variable (ej. muchos clientes simultáneos)\nQueremos evitar el siguiente escenario\n\n\n\n\n\n1.- Servicios robustos $\\rightarrow$ Sistema Distribuido (SD)\nLa única opció para tener Disponibilidad + Escalabilidad es utilitzar un SD para la parte servidor\nSistema Distribuido = \n\ncolección de ordenadores (nodos) interconectados en red\n(+) coopeeran entre si\n(+) ofrecen imagen de máquina única\n\nImplantamos servidores robustos utilizando un SD especializado denominado cluster altamente disponible\n\n1.- Servicios robustos: Cloud Computing\n\nDesarrollar y mantener un cluster altamente disponible es muy costoso (hardware, software, personal de mantenimento, ...)\nUna opción es externalitzar $\\rightarrow$ dejar esa tarea a empresas especializadas, acceder via internet, y pagar por uso:\nLos centros de computación externos son SD que dan garantías de disponibilidad y escalabilidad\nEs muy flexible (la empresa cliente puede variar la cuota segús sus necesidades en cada momento)\nHablamos de de potencia computacional, espacio de almacenamiento, etc. garantizado por un proveedor mediante centros de cómputo repartidos globalmente $\\rightarrow$ tenemos transparencia de ubicación, y por eso decimos que todo está en la &#39;nube&#39;\n\n\n\n\n1.- Servicios robustos: Preguntas\nPlantéate las siguientes cuestiones:\n\n¿Tendría sentido actualmente un dispositivo que no implemente los estandards de internet?\n¿Donde están físicamente los servidors de DropBox, Facebook, WhatsApp, Wikipedia, etc.?\n¿Qué arquitectura tienen esos servidores?\n\n\n2.- Cooperación para resolver problemas complejos\nAlgunas aplicaciones no pueden abordarse con un ordenador &#39;normal&#39;\n\nMuchos proyectos científicos y de ingenieria son muy complejos (SETI, genoma, desarrollo de vacunas)\nAlgunas aplicaciones deben atender miles de solicitudes simultáneas (buscadores, wikipedia)\n\nAlternativas    \n\nUn super-ordenador $\\rightarrow$ carísimo, no ofrece escalabilidad ni elevada disponibilidad\nSD: Cooperación de varios equipos &#39;normales&#39; siguiendo determinado patrón de diseño. Podemos:\nAprovechar potencia de cómputo infrautilizada $\\rightarrow$ computación cooperativa\nUtilizar ordenadores dedicados (organizados en patrones Map/reduce, patrón Broker/Workers, ..)\n\n\n\n\n2.- Cooperación ... .- Computación cooperativa\n\nMuchos PCs infrautilizados, y muchos problemas complejos de interés global (ej.- investigación en salud) \nEl propietario de un equipo dona parte de su potencia de cálculo de forma altruista para ayudar a resolver alguno de estos problemas\n\nLa entidad responsable (universidad, instituto de investigación, etc.) pide colaboración\n\nDescompone el problema en una colección de subproblemas\nDesarrolla un servidor que mantiene la lista de clientes (nodos dados de alta) \nCalcula la respuesta final a partir de las respuestas parciales generadas por los clientes\n\nCada equipo voluntario (cliente)\n\nSe dá de alta $\\rightarrow$ recibe del servidor e instala software específico \nEl software cliente pide trabajo al servidor cuando el equipo está infrautilizado, procesa los datos que envia el servidor, y devuelve respuesta\n\n\n2.- Cooperación ... .- patrón Map/Reduce\nPartimos de una misma operación a aplicar sobre una cantidad enorme de información\n\nEl servidor reparte fragmentos de información a cada nodo, y el nodo aplica esa operació sobre los datos que recibe\nCada nodo calcula su parte y envía la respuesta\nEl servidor calcula la solución a partir de las respuestas parciales\n\n\n\n2.- Cooperación ... : patrón Broker-Workers\n\nAsumimos varias tareas y varios nodos worker equivalentes\nUn nodo broker actúa como intermediario: recibe todas las solicitudes, y reparte las tareas entre los workers (equilibra la carga entre workers)\n\n\n\n2.- Cooperación ... .- Preguntas\nPlantéate las siguientes cuestiones:\n\n¿Porqué necesitamos dar de alta a un cliente en el modelo de computació cooperativa?\nPiensa en algún tipo de problema en el que se pueda aplicar Map/Reduce\nEn el patrón broker/workers todas las solicitudes y las respuestas pasan por el broker. ¿Dicho broker se convierte en un cuello de botella? ¿Implica que el sistema no puede ser escalable?\n\n\n3.- Nueva funcionalidad\nLa parte cliente ya no es necesariamente una persona frente a un interfaz usuario \n\nLos clientes forman parte de un SD, y cooperan con el servidor. Posibilidades:\nEl cliente es una aplicació $\\rightarrow$ Bussiness to Bussiness (B2B)\nLa parte cliente y la parte servidor pueden intercambiar mensajes http con text JSON o XML\n\n\nEl cliente es un Mot (ordenador de bajo coste que dispone de sensores y posiblemente actuadores)\nEl mot está integrado en un dispositivo (electrodomésticos, vehiculos, etc.)\n\n\n\n\n3.- Nueva funcionalidad.- Mots\n\nRedes de sensores. Los mots son muy simples \nTienen sensors: monitorizan su entorno y envían datos a un servidor\nMuy poca capacidad de cálculo\nÚtiles para vigilancia, monitoritzación, ...\n\n\nInternet de las cosas (IoT)\nMots más elaborados: sensores, actuadores (pueden alterar su entorno), y más potencia\nAdemás de interactuar con el servidor pueden colaborar entre ellos\nÚtiles en medicina, fabricación, y en general automatización de procesos, ciudades inteligentes, ...\n\n\n\n\n3.- Nueva funcionalidad.- Preguntas\nPlantéate las siguientes cuestiones:\n\nEn B2B, ¿se necesita un navegador en la parte cliente?\nUna posible aplicación de les redes de sensores es monitorizar el tráfico en una ciudad. ¿Qué utilidad tendría ese sistema?\nSi aplicamos IoT a control de tráfico en una ciudad, ¿que funcionalidad podemos añadir respecto a la que proporciona una red de sensores?\n\n\nResumen: Áreas aplicación SD\n\nServicios robustos (escalables y disponibles)\nClusters altamente disponibles\n(externalización) Cloud Computing\n\n\nDescomposición de problemes\nDonación altruista de potencia de cómputo de dispositivus infrautilizados: Computación cooperativa\nPatrones de cooperación: Map/Reduce, Broker/Workers, ...\n\n\nNueva funcionalidad\nSistemas B2B\nMots\nRedes de sensores\nIoT (Internet of Things)\n\n\n\n\n\n", "tags": "", "url": "sesion/areasaplicsd/aaplic.html"},
		{"title": "Despliegue de Servicios. Docker", "text": "\nDespliegue de Servicios. Docker\nTSR 2021, Juansa Sendra, Grupo B\n\n\nComponentes e instancias, dependencias\n\nAplicación distribuida = colección de componentees heterogéneos dispersos sobre una red de computadores\nEjemplo.- 1 componentee cliente con varias instáncias, 1 componentee broker con una instancia, 1 componentee workers con varias instancias\nCada instancia\npuede iniciarse/detenerse/reiniciarse de manera independiente\nfalla de forma independente al resto\nposee una ubicación propia (independente)\n\n\n\n\nLos componentees cooperan $\\rightarrow$ existen dependencias = valores que debe conocer un componentee pero dependen de otro(s)\nEjemplo.- los clientes deben tener identidad única y conocer el frontend, los workers deben tener identidad única y conocer el backend\n\n\n\n\nRequisitos ejecución\n\nLos nodos pueden ser heterogéneos (diferentes equipos, SO, etc.)\nCada componentee tendrá ciertos requisitos para su ejecución\nNota.- en nuestro caso utilizamos nodeJS y 0MQ para todos los componentees, pero podríamos desarrollar cada componentee con distintos lenguajes, bibliotecas, etc.\n\n\nPodemos tener requisitos adicionales de seguridad (privacidad, autenticación, etc.)\n\n\nDespliegue = preparación de un sofware para su utilización\n\nEjecución del software\nInstalación.- resolver dependencias del software (ej. bibliotecas), configurar (ej. versiones compatibles), determinar número de instancias de cada componentee y la forma de repartirlas entre los nodos\nActivación.- establecer el orden en que arrancan los componentees\n\n\nDesactivación.- detener el sistema de forma ordenada\nActualización.- reemplazar componentees (ej. nueva versión)\nAdaptación.- recuperación de errores, cambios en la configuración de los agentes, escalado (reacción ante cambios en la carga)\n\n\nDespliegue manual. Ejemplo\n\nGarantizar que cada nodo dispone de la instalación base\nNodeJS, ZeroMQ (con las versiones correctas)\n\n\nCopiar el código fuente de cada componentee (client, broker, worker) al nodo adecuado\nLanzar los componentees en el orden correcte (y con los args. correctos en línea de órdenes)\nnode broker frontend backend\npara cada worker: node worker id backend\npara cada client: node client id frontend\n\n\n¿Qué pasa si tenemos 12 workers y 80 clientes? ¿Y si modificamos el código cliente?\nNecesitamos automatizar el despliegue\n\n\n\n\nDespliegue de servicios = instalación, activación, actualitzación y adaptación del servicio\n\nDesarrollamos aplicaciones distribuidas para proporcionar servicios (funcionalidad, Ej. DropBox, Wikipedia, ...) a clientes remotos con garantías de escalabilidad y disponibilidad\nservicio = Aplicación + despliegue (únicamente resulta utilizable una vez desplegado)\n\n\nUn servicio extablece un SLA (Service Level Agreement)\nDefinición funcional (qué hace)\nRendimiento (cantidad de clients que soporta, tiempo de respuesta esperado)\nDisponibilidad (% del tiempo que garantizamos servicio disponible)\nNos centramos en servicios persistentes (disponibilidad continua)\n\n\n\n\n\n\nAutomatización del despliegue\n\nConfiguración para cada componentee\nFichero con una lista de parámetros de configuración y descripciones de dependencias\nLa herramienta genera una configuración específica para a cada instancia del componentee\nEjemplo (a partir de aquí le llamamos CBW (client/Broker/Workers)\npara client: args id y frontend, dependencia respecto a broker\npara broker: args frontend y backend\npara worker: args id y backend, dependencia respecto a broker\n\n\n\n\n\n\nAutomatización del despliegue\n\nPlan de configuración global\nPlan de conexión entre componentees (lista de endpoints expuestos, lista de dependencias)\nEn CBW los endpoints son frontend y backend\nPodríamos leer los datos de un fichero, recibir datos en un socket, etc.\nPero utilizaremos Inyección de dependencias\nEl código de la aplicación expone nombres\nUna herramienta asocia las variables con instancias de objectes\n\n\n\n\nDecidimos donde colocar cada instancia y el orden de arranque\nEn CBW orden broker, workers, clients\n\n\nEnlace (&#39;binding&#39;) de dependencias (empareja los endpoints, incluyendo dependencias de servicios externos)\nEn CBW no hay dependencias externas\n\n\n\n\n\n\nDespliegue en la nube (IaaS)\n\nSe basa en virtualización\nMáquinas virtuales de distintos tamaños\nFlexibilidad en la asignación de recursos\n\n\nPresenta limitaciones en el despliegue\nDecisiones de asignación no automáticas (bajo nivel)\nNúmero de instancias por componente, ubicación, tipos de MV\n\n\nNo permite elegir características de la red (retardo, ancho de banda)\nModelo de fallos insuficiente\nLos modos de fallo no son realmente independientes\nAyuda limitada para la recuperación tras un fallo\n\n\n\n\n\n\nDespliegue en la nube (PaaS)\n\nSLA como element central $\\rightarrow$ parámetros del SLA para todos los componentes\nSe persigue la automatización del despliegue\nPlanes de despliegue a partir del SLA\nPlanes para actualización/configuración\n\n\nSituación actual\nEl grado de automatización ha mejorado en los últimos años\nIncluye el despliegue inicial y el autoescalado de servicios sencillos\nTodavía no garantiza la actualización de los servicios respecto a su SLA\n\n\nMicrosoft Azure es uno de los mas evolucionados\n\n\n\n\n\n\nAutomatización del despliegue.- contenedores\n\nAprovisionamiento = reservar la infraestructura necesaria\nrecursos para intercomunicación entre instancies\nrecursos para cada instancia (procesador, memoria, ..). Alternativas:\n\n\n\n\n\nContenedor vs MV\n\nMenor flexibilidad\nEl software de la instancia ha de ser compatible con el SO anfitrión\nEl aislamiento entre contenedores no es perfecto\n\n\nLigero (utiliza muchos menos recursos)\nEj.: desplegamos 100 instancias de un componente cuya ejecución requiere 900MB (SO) + 100MB (resto)\ncon MV: 100*(900MB + 100MB) = 100GB\ncon contenedores: 900MB + 100*100MB = 10.9GB\nAhorramos espacio y tiempo (ej. para instalar la imagen)\n\n\nMayor facilidad de despliegue (fichero de configuración)\nAplicable en casi todos los escenarios\n\n\n\n\nContenedores.- Docker\n\nEl fichero de configuración Dockerfile automatiza el despliegue de cada instancia\nSoporta control de versiones (Git)\nAdemás del sistema de ficheros nativo, define un sistema de ficheros de solo lectura para compartición entre contenedores\nPermite cooperación en el desarrollo mediante depósitos públicos\n\nNOTA.-Asumimos que el SO anfitrión es Linux (aunque existe Docker para Windows)\n\nComponentes Docker\n\nImagen = plantilla de solo lectura con las instrucciones para crear un contenedor (cómo llegar a un contexto de ejecución determinado)\nEj.-podemos crear una imagen para proporcionar Linux+NodeJS+zmq, a la cual denominamos centos-zmq\nPodemos construir las imagen que necesitamos. Al final tenemos que definir una imagen por componente (ej. imágenes para client, broker, worker)\n\n\ncontenedor = Conjunto de recursos que necesita una instancia para ejecutarse. Se crea al ejecutar una imagen\nEj.-para probar el código de la práctica 2, ejecutamos cada instancia sobre un contenedor creado a partir de centos-zmq\n\n\nDepósito = lugar donde podemos dejar/obtener imágenes (espacio para compartir imágenes)\nEx.-Podemos subirr la imagen centos-zmq, y cualquiera puede bajarla y usarla para crear contenedores\n\n\n\n\nCreación de una imagen\n\nEn el depósito tenemos imágenes predefinidas para las distintas distribuciones Linux\nEj. imagen centos:7.4.1708\n\n\nNuevas imágenes = imagen base + instrucciones\nA partir de centos:7.4.1708 + instrucciones para instalar nodeJS $\\rightarrow$ centos-nodejs\nA partir de centos-nodejs + instrucciones para instalar zmq $\\rightarrow$ centos-zmq\nA partir de centos-zmq + ... $\\rightarrow$ client\nA partir de centos-zmq + ... $\\rightarrow$ broker\nA partir de centos-zmq + ... $\\rightarrow$ worker\n\n\n\n\nCreación de una imagen (2 alternativas)\n1 Manual\n\ncargar una imagen base existente y crea un contenedor interactivo (terminal) a partir de esa imagen\nintroducir instrucciones a mano desde consola (modificar contenedor)\ncrear nuevo imagen a partir del estat actual del contenedor\n2 Automática\nCrear fichero de texto con instrucciones $\\rightarrow$ llamado Dockerfile\ndar la orden para construir la imagen a partir del Dockerfile\n\n\nCreación de una imagen.- ejemplo alternativa manual\n\ncargar una imagen base existente y crear un contenedor interactivo (terminal) a partir de esa imagen\n$ docker run -i -t centos:7.4.1708 bash\n\nintroducir instrucciones a mano desde consola (modificar contenedor)\n$ curl --silent --location https://rpm.nodesource.com/setup_10.x | bash -\n$ yum install -y nodejs\n$ yum install -y epel-release\n$ yum install -y zero-devel\n$ yum install -y make python gcc-c++\n$ rpm install zeromq@5\n$ exit\n\ncrear nueva imagen a partir del estado actual del contenedor$ docker ps -a\n$ docker commit idcontenedor centos-zmq\n\n\n\nCreación de una imagen.- ejemplo alternativa automática (Dockerfile)\n\nCrear fichero de texto con instrucciones $\\rightarrow$ llamado DockerfileFROM centos:7.4.1708\nRUN curl --silent --location https://rpm.nodesource.com/setup_10.x | bash -\nRUN yum install -y nodejs\nRUN yum install -y epel-release\nRUN yum install -y zeromq-devel make python gcc-c++\nRUN npm install zeromq@5\n\ndar la orden para construir la imagen a partir del Dockerfile\nasumiendo que estamos en el directorio donde está el Dockerfile$ docker build -t tsr1718/centos-zmq .\n\n\n\n\n\nDocker.- órdenes (acciones)\n\nDocker utiliza órdenes desde consola: $ docker acción opciones argumentos\nPodemos agrupar las diferentes acciones en grupos (NO estudiamos todas las acciones)\nOperaciones sobre contenedores (ciclo de vida): run, build, commit, start, stop\nOperaciones informativas: ps, info, images, history\nAcceso al depósito: pull, push\nOtras: cp, export\n\n\n\n\nDocker.- órdenes principales (1)\n\ndocker run -i -t imagenBase progInicial\ncrea un contenedor interactivo a partir de imagenBase, arranca progInicial\n\n\ndocker commit idcontenedor nombreNuevaimagen\nguarda el estado actual del contenedor como una nueva imagen\n\n\ndocker build -t nombreNuevaimagen pathDockerfile\nguarda el estado del contenedor como una nueva imagen\n\n\ndocker start idcontenedor\narranca la ejecución del contenedor\n\n\ndocker stop idcontenedor\ndetiene la ejecución del contenedor\n\n\n\n\nDocker.- órdenes principales (2)\n\ndocker ps -a\nlista todos los contenedores y su estado\n\n\ndocker images\nlista de todas las imágenes a nivel local\n\n\ndocker history idImage\nmuestra la historia de una imagen\n\n\ndocker pull idimagen\nobtiene copia local de una imagen que está en el depósito\n\n\ndocker push idimagen\ndeja en el depósito copia de una imagen local\n\n\n\n\nDocker.- Fichero Dockerfile (para automatizar la creación de una imagen)\n\nLa primera línea debe ser: FROM imagenBase\nOtras líneas tienen la estructura: acción argumentos\nRUN orden ejecuta la orden en el shell\nADD origen destino copia ficheros desde la máquina anfitrión al contenedor\nSi el origen es un directorio, lo copia completo. Si es un fichero comprimido, lo expande al copiar\n\n\nCOPY origen destino idem ADD, pero no expande los ficheros comprimidos\nEXPOSE port indica un port en el cual el contenedor atenderá peticiones\n\n\n\n\nDocker.- Fichero Dockerfile (cont)\n\nWORKDIR path indica directorio de trabajo para las órdenes RUN, CMD, ENTRYPOINT\nENV variable valor asigna valor a una variable de entorno (accesible para los programes dentro del contenedor)\nCMD orden args proporciona valores por defecto para la ejecución del contenedor\nENTRYPOINT orden args ejecuta esta orden al crear el contenedor\nSi tenemos varias órdenes CMD o ENTRYPOINT, sólo ejecuta la última\n\n\n\n\nEjemplo broker/workers.- Alternativas para organizar los componentes\n\n\nEntorno de pruebas.- varios componentes en el mismo nodo\n\nInteracción entre componentes en una misma máquina (como en el laboratorio)\nDebemos definir una imagen por componente, y crear un contenedor por instancia\nEstudiamos 2 alternativas (y luego nos centramos en la primera)\ntodos los componentes (client, broker, worker) en la misma máquina\nbroker y workers en un máquina, clientes remotos en otras máquinas\n\n\n\n\nEjemplo CBW.- patrón broker/worker\n\ncomponente broker (broker.js)\nnode broker portFront portBack (per defecte 9998 9999)\n\n\ncomponente worker (worker.js)\nnode worker urlBack (per defecte tcp://localhost:9999)\nnormalmente tendremos varias instancias\n\n\ncomponente client (client.js)\nnode client urlFront (per defecte tcp://localhost:9998)\nnormalmente tendremos varias instancias\n\n\n\n\nEjemplo con todos los componentes en un nodo\n\nOrganizamos la siguiente estructura de directoriosCBW/\ndocker-compose.yml\nclient/\n  client.js\n  Dockerfile\nbroker/\n  broker.js\n  Dockerfile\nworker/\n  worker.js\n  Dockerfile\n\nLos ficheros Dockerfile permiten crear las imágenes que permiten lanzar contenedores\nEl fichero docker-compose.yml es un plan global de despliegue\n\n\nTodos los componentes en un nodo ... ¿dependencias?\n\nbroker/Dockerfile\nFROM tsr2021/ubuntu-zmq\nCOPY ./broker.js broker.js\nEXPOSE 9998 9999\nCMD node broker\n\nIP del broker = asociada al contenedor del broker, desconocida hasta ejecutarlo\n\nworker/Dockerfile. worker debe conocer la URL (IP y port) del backend\nFROM tsr2021/ubuntu-zmq\nCOPY ./worker.js worker.js\nCMD node worker tcp://????:9999\n\nclient/Dockerfile. client debe conocer la URL (IP y port) del frontend\nFROM tsr2021/ubuntu-zmq\nCOPY ./client.js client.js\nCMD node client tcp://????:9998\n\n\n\nTodos los componentes en un nodo ...  ¿dependencias?\n\nlanzamos el broker en su contenedor (desde el directorio broker)\ndocker build -t broker . crea la imagen\ndocker run -d broker lanza el contenedor\n\n\nobtenemos la IP de ese contenedor\ndocker ps -a para conocer la ID del contenedor\ndocker inspect IDcontenedor per a llegir la IP (ex. 192.154.3.12)\n\n\nmodificamos el valor de la IP en el Dockerfile de worker\nlinia CMD node worker tcp://192.154.3.12:9999\ndocker build -t worker . crea la imagen\n\n\nmodificamos el valor de la IP en el Dockerfile de worker\nlínea CMD node client tcp://192.154.3.12:9998\ndocker build -t client . crea la imagen\n\n\n\n\nTodos los componentes en un nodo ...  ¿dependencias?\n\nlanzamos workers y clients\ndocker run -d worker lanza el contenedor\n... (una vez por instancia)\n\n\ndocker run -d client lanza el contenedor\n... (una vez por instancia)\n\n\n\n\n\n\nEjemplo con todos los componentes en un nodo. Automatización (variables)\n\nbroker/DockerfileFROM tsr2021/ubuntu-zmq\nCOPY ./broker.js broker.js\nEXPOSE 9998 9999\nCMD node broker\n\nworker/Dockerfile (variable $BACKEND_URL)FROM tsr2021/ubuntu-zmq\nCOPY ./worker.js worker.js\nCMD node worker $BACKEND_URL\n\nclient/Dockerfile (variable $FRONTEND_URL)FROM tsr2021/ubuntu-zmq\nCOPY ./client.js client.js\nCMD node client $FRONTEND_URL\n\n\n\nComponentes en un nodo. Automatización (plan global)\ndocker-compose.yml describe componentes, propiedades, relaciones \nversion: &#39;2&#39;\nservices:\n   cli:\n      image: client\n      build: ./client/\n      links:\n        - bro\n      environment:\n        - FRONTEND_URL=tcp://bro:9998\n   bro:\n      image: broker\n      build: ./broker/\n      expose:\n        - &quot;9998&quot;\n        - &quot;9999&quot;\n   wor:\n      image: worker\n      build: ./worker/\n      links:\n        - bro\n      environment:\n        - BACKEND_URL=tcp://bro:9999\n\nComponentes en un nodo. Automatización (plan global)\n\nA partir del plan global podemos levantar el sistema con una orden única\ndocker-compose up -d --scale worker=4 --scale client=7\npermite otras opciones (se describen en la guia del alumno)\n\n\n\n\nEjemplo con clientes remotos\n\nOrganizamos la siguiente estructura de directoriosCBW/\ndocker-compose.yml\nbroker/\n  broker.js\n  Dockerfile\nworker/\n  worker.js\n  Dockerfile\n\nLos ficheros Dockerfile son para crear les imágeness que permiten lanzar contenedores\nEl fichero docker-compose.yml es un plan global de despliegue (para la automatización)\n\n\nClientes remotos.- manual\n\nbroker/DockerfileFROM tsr2021/ubuntu-zmq\nCOPY ./broker.js broker.js\nEXPOSE 9998 9999\nCMD node broker\n\nIP del broker = asociada al contenedor del broker, desconocida hasta ejecutarlo\nworker/Dockerfile. worker debe conocer la URL (IP y port) del backendFROM tsr2021/ubuntu-zmq\nCOPY ./worker.js worker.js\nCMD node worker tcp://????:9999\n\n\n\nClientes remotos.- manual\n\nLanzamos el broker en su contenedor (desde el directorio broker)\ndocker build -t broker . crea la imagen\ndocker run -p 8000:9998 -d broker lanza el contenedor\nLa opción -p portAmfitrió:portcontenedor permite acceso al frontend desde el exterior (port 8000 del anfitrión)\nLa opción -d lanza el contenedor en segundo plano\n\n\n\n\nobtenemos la IP de ese contenedor\ndocker ps -a para conocer la ID del contenedor\ndocker inspect IDcontenedor para leer la IP (ex. 192.154.3.12)\n\n\nmodificamos el valor de la IP en el Dockerfile de worker\nlinia CMD node worker tcp://192.154.3.12:9999\ndocker build -t worker . crea la imagen\n\n\n\n\nClientes remotos.- manual\n\nlanzamos workers\ndocker run -d worker lanza el contenedor\n... (una vez por instancia)\n\n\nlanzamos clientes (desde las máquinas correspondientes)\nNo es necesario gestionar los clientes con contenedores\nHan de conectar con tcp://ipDelAnfitrión:8000\n\n\n\n\nClientes remotos.- automatización\n\nVariable de entorno en worker/DockerfileFROM tsr2021/ubuntu-zmq\nCOPY ./worker.js worker.js\nCMD node worker $BACKEND\n\n\n\nClientes remotos.- automatización\n\nplan global de despliegueversion: &#39;2&#39;\nservices:\n bro:\n    image: broker\n    build: ./broker/\n    ports:\n      - &quot;8000:9998&quot;\n    expose:\n      - &quot;9999&quot;\n wor:\n    image: worker\n    build: ./worker/\n    links:\n      - bro\n    environment:\n      - BACKEND=tcp://bro:9999\n\n\n\nClientes remotos.- automatización\n\norden (para 3 workers) docker-compose up --scale worker=3\nlanzamos clientes (desde las máquinas correspondientes)\nNo es necesario gestionar los clientes con contenedores\nHan de connectar a tcp://ipDelAnfitrión:8000\n\n\n\n\nProducción.- componentes repartidos en distintos nodos\n\nLa propuesta mas conocida es kubernetes\nEs un orquestador de contenedores, pero no depende de Docker\nla guía del tema proporciona una descripción general de sus elementos\n\n\nElementos principales de kubernetes\nCluster y node (físico o virtual)\nPod: menor unidad desplegable\nincluye contenedores que comparten espacios de nombres y volumenes\n\n\nControladores de replicación: encargados del cicle de vida de un grupo de pods\nescala, replica y recupera pods para asegurar N instancies en ejecución\n\n\nControladores de despliegue: actualizan la aplicación distribuida\nservicio: define un conjunto de pods y la forma de acceso\nSecretos (gestión de credenciales)\nVolúmenes (persistencia)\n\n\n\n", "tags": "", "url": "sesion/desplegament/despliegue.html"},
		{"title": "Tarea.- definir una familia de funciones relacionadas", "text": "Tarea.- definir una familia de funciones relacionadas\nTSR 2021, Grupo B\n\nSumas parciales de los valores de un vector sums([2,3,4,1]) // [2, 5, 9, 10]\nProductos parciales de los valores de un vector prods([2,3,4,1]) //[2, 6, 24, 24]\nMáximos parciales de los valores de un vector maxs([2,3,4,1]) // [2, 3, 4, 4]\nMínimos parciales de los valores de un vector mins([2,3,4,1]) // [2, 2, 2, 1]\n\n\nPrimer intento: funciones independientes\nLa estructura es muy similar en todas (hablamos de una familia de funciones). \n\nRecibimos como argumento el vector a\ndefinimos un vector local b sobre el que vamos calculando resultados\nrecorremos a en un bucle (y en cada iteración añadimos un elemento a b)\nfinalmente devolvemos el vector bfunction x (a) {\nlet b = []\nfor .. {\n  ... // accede al siguiente elemento de a\n  b.push(..) // añade valor a b\n}\nreturn b\n}\n\n\n\n\nfunction sums (a) {                                 function mins (a) {\n   let b = []                                          let b = []\n   let acc = a[0]                                      let acc = a[0]\n   b.push(acc)                                         b.push(acc)\n   for (i=1; i&lt;a.length; i++){                         for (i=1; i&lt;a.length; i++){\n      acc = a[i]+acc                                      acc = a[i]&lt;acc? a[i]:acc\n      b.push(acc)                                         b.push(acc)\n   }                                                   }\n   return b                                            return b\n}                                                   }\n\nfunction prods (a) {                                function maxs (a) {\n   let b = []                                          let b = []\n   let acc = a[0]                                      let acc = a[0]\n   b.push(acc)                                         b.push(acc)\n   for (i=1; i&lt;a.length; i++){                         for (i=1; i&lt;a.length; i++){\n      acc = a[i]*acc                                      acc = a[i]&gt;acc? a[i]:acc\n      b.push(acc)                                         b.push(acc)\n   }                                                   }\n   return b                                            return b\n}                                                   }\n\nlet v = [2,3,4,1]\nconsole.log(sums(v), prods(v), mins(v), maxs(v))\n\n\nPero la solución NO es correcta: funciona mal si el vector está vaciov = []; console.log(sums(v), prods(v), mins(v), maxs(v))\n\n\n\n\nCorrigiendo el error\n\nDebe corregirse igual en todos para evitar inconsistencias\n`js\nfunction sums (a) {                                 function mins (a) {\n let b = []                                          let b = []\n if (a.length==0) return b                            if (a.length==0) return b\n let acc = a[0]                                      let acc = a[0]\n b.push(acc)                                         b.push(acc)\n for (i=1; i&lt;a.length; i++){                         for (i=1; i&lt;a.length; i++){acc = a[i]+acc                                      acc = a[i]&lt;acc? a[i]:acc\nb.push(acc)                                         b.push(acc)\n }                                                   }\n return b                                            return b\n}                                                   }\n\nfunction prods (a) {                                function maxs (a) {\n   let b = []                                          let b = []\n   if (a.length==0) return b                            if (a.length==0) return b\n   let acc = a[0]                                      let acc = a[0]\n   b.push(acc)                                         b.push(acc)\n   for (i=1; i&lt;a.length; i++){                         for (i=1; i&lt;a.length; i++){\n      acc = a[i]*acc                                      acc = a[i]&gt;acc? a[i]:acc\n      b.push(acc)                                         b.push(acc)\n   }                                                   }\n   return b                                            return b\n}                                                   }\nlet va = [2,3,4,1], vb = []\nconsole.log(sums(va), prods(va), mins(va), maxs(va))\nconsole.log(sums(vb), prods(vb), mins(vb), maxs(vb))\n\n---\n## Segundo intento: función única parametrizable. \nPodemos aprovechar el hecho de que son funciones muy parecidas para definir únicamente una función y parametrizarla con la operación a aplicar sobre cada par de valores. \n- NOTA.- es más general, porque puede usarse como arg cualquier función de dos parámetros\n```js\nfunction fs (a,f) { // a=array, f=funcion a aplicar\n   let b = []\n   let acc = a[0]\n   b.push(acc)\n   for (i=1; i&lt;a.length; i++){ //cada elem de a\n      acc = f(acc,a[i])\n      b.push(acc)\n   }\n   return b\n}\n\nHemos introducido el mismo error que en la solución original. Lo corregimos\n\n\nfunction fs (a,f) {\n   let b = []\n   if (a.length==0) return b\n   let acc = a[0]\n   b.push(acc)\n   for (i=1; i&lt;a.length; i++){ //cada elem de a\n      acc = f(acc,a[i])\n      b.push(acc)\n   }\n   return b\n}\nlet va = [2,3,4,1], vb=[]\n\nPodemos invocar usando funciones anónimas o usar funciones auxiliares\nconsole.log(fs(va,(a,b)=&gt;a+b), fs(va,(a,b)=&gt;a*b), fs(va,(a,b)=&gt;a&lt;b?a:b), fs(va,(a,b)=&gt;a&gt;b?a:b))\nconsole.log(fs(vb,(a,b)=&gt;a+b), fs(vb,(a,b)=&gt;a*b), fs(vb,(a,b)=&gt;a&lt;b?a:b), fs(vb,(a,b)=&gt;a&gt;b?a:b))\n\nconst sum  = (a,b)=&gt;a+b\nconst prod = (a,b)=&gt;a*b\nconst min  = (a,b)=&gt;a&lt;b?a:b\nconst max  = (a,b)=&gt;a&gt;b?a:b \nconsole.log(fs(va,sum), fs(va,prod), fs(va,min), fs(va,max))\nconsole.log(fs(vb,sum), fs(vb,prod), fs(vb,min), fs(vb,max))\n\n\nTercer intento: función que devuelve a otra (fija arg funcion)\nfunction fs(f) {\n    return a =&gt; {\n          let b=[]\n       if (a.length==0) return b\n       let x=a[0]\n       b.push(x)\n       for (let i=1; i&lt;a.length; i++) {\n           x = f(x,a[i])\n           b.push(x)\n       }\n       return b\n    }\n}\nconst sums  = fs((a,b)=&gt;a+b)\nconst prods = fs((a,b)=&gt;a*b)\nconst mins  = fs((a,b)=&gt;a&lt;b?a:b)\nconst maxs  = fs((a,b)=&gt;a&gt;b?a:b) \nlet va = [2,3,4,1], vb = []\nconsole.log(sums(va), prods(va), mins(va), maxs(va))\nconsole.log(sums(vb), prods(vb), mins(vb), maxs(vb))\n\n", "tags": "", "url": "sesion/progFuncional/familiaFunc.html"},
		{"title": "Ciclo de vida de un servicio", "text": "\nCiclo de vida de un servicio\nTSR 2021. Grupo B, Juansa Sendra\n\n\nEvolución histórica de los sistemas informáticos (desde el principio ...)\n\nmainframes (equipos caros, compartidos, propiedad de una institución -ej. universidad-)\nCompartido $\\rightarrow$ buena utilización\nPocos usuarios (baja utilización). Matemáticos, ingenieros, etc.\nInterfaz poco amigable\nMuchos usuarios piden la instalación de los programas que necesitan, o desarrollan sus propios programas\n\n\nBajo coste para el usuario\nGestión, configuración administración y mantenimiento por personal especilizado\n\n\nPCs (equipos baratos, interfaz amigable)\nCada usuario su equipo -&gt; no hay contención, baja utilización\nEl coste de adquisición, configuracio, mantenimiento, etc. corresponde al usuario\nEl usuario no actúa como desarrollador, pero tiene que administrar el sistema.\n\n\n\n\nEvolución històrica de los sistemas informáticos (... a la actualidad)\n\nCentro de cómputo empresarial (cluster de alta disponibilidad)\nRequiere personal especializado (proveedor, administrador) $\\rightarrow$ eleva el coste\nEl coste de adquisición se carga a la empresa\nEn algunos casos la empresa desarrolla parte de los programas\n\n\nCC (Cloud Computing) = externalización del cluster\nEvita coste adquisición, acota coste administración y mantenimiento $\\rightarrow$ coste por uso (flexible, previsible)\nAcceso a través de la red (desde navegador web) gracias a:\nmejoras en redes ($\\uparrow$ ancho de banda, $\\downarrow$ latencia)\nmejoras en los navegadores (mejora interfaz, reducción carga en el servidor)\n\n\nCompartición eficiente de recusos, adaptación a cantidades de usuarios variable\n\n\n\n\nCiclo de vida de un servicio.- Roles\n\ndesarrollador: implanta los componentes\nproveedor: decide las caracteristicas del servicio, los componentes que lo forman, y la forma en que debe configurarse y administrarse\nadministrador: se preocupa de que cada componente soft y hard esté en su sitio y correctamente configurado\nusuario: utiliza el (accede al) servicio\n\n\nEvolución histórica.- Roles\n\n\n\n\ndesarrollador\nproveedor\nadministrador\nusuario\n\n\n\n\nmainframes\nusuario\nusuario\nespecialistas\npocos (baja contención)\n\n\nPCs\nempresasSoft\npropietario\npropietario\núnico (propietario)\n\n\nCentro còmputo\nempresasSoft\nespecialistas\nespecialistas\nmolts (empleats empresa)\n\n\nCloud Computing\nproveedorServicio\nproveedorServicio\nespecialistas\nmuchísimos\n\n\n\n\nCloud Computing (CC).- Niveles\nCuando hablamos de CC pensamos en la utilización de aplicaciones (servicios), pero podemos diferenciar 3 niveles:\n\nSaaS facilita el uso de una aplicación como un servicio robusto\nPaaS automatiza la gestión de recursos, facilita la creación y despliegue de servicios\nIaaS proporciona elasticidad\n\nGrosso modo corresponde a los niveles que encontramos en cualquier sistema\n- SaaS = Aplicaciones\n- PaaS = Sistema Operativo\n- IaaS = Hardware\n\nCloud Computing.- SaaS (Software as a Service)\n\nContención limitada: se reservan recursos para la demanda esperada\nInicialmente, inflexible: el proveedor limita la cantidad de recursos, compartición de recursos dificil\nPosteriormente, elasticidad (flexibilidad)\nMercado competitivo de servicios\n\n\nEl proveedor debe utilizar los recursos de forma eficiente\n\n\nCloud Computing.- PaaS (Platform as a Service)\n\nTodavía en sus inicios\nFacilita el desarrollo y puesta en marcha de servicios\nEspecifica (equivale a SO)\nUn modelo de servicios\nUn modelo de desarrollo de sus componentes soft\nUn modelo de configuración i gestión del ciclo de vida (composición, configuración, despliegue, actualización)\nUn modelo de rendimento (monitorización de parámetros relevantes, expresión de puntos de elasticidad, reconfiguración en función de la carga)\n\n\n\n\nCloud Computing.- IaaS (Infraestructure as a Service)\n\nAsigna/redistribuye recusos de cómputo bajo petición (peticiones via API)\nPodemos pedir capacidades concretas para los ordinadores y red (ej. adaptándose a la carga)-&gt; elasticidad\nPodemos cargar las imágenes de SO que nos interesen\n\n\nPosible gracias a la tecnologia de virtualización\nFàcil assignar/configurar recursos de cómputo virtuales, instalar imagen de sistema sobre una máquina virtual\n\n\n\n\nCicle de vida de un servei.- Qüestions\nPlantéate las siguientes preguntas\n\nLos roles de proveedor y administrador pueden llegar a confundirse. ¿Puedes pponer ejemplos que ilustren las diferencias?\nMainframes i Cloud Computing se parecen en algunos aspectos. Indica similitudes y diferencias\nCuando utilizass dropBox, ¿Cuál de los tres niveles CC estas utilizando?. \nSi desarrollo un juego cooperativo y necesito un cluster externalizado para implantar el servidor, ¿qué nivel de CC he de utilizar?\n\n", "tags": "", "url": "sesion/roles/cc.html"},
		{"title": "Servidores Escalables", "text": "\nServidores Escalables\nTSR 2021. Grupo B, Juansa Sendra\n\n\nServidores Escalables\n\nPara implantar servicios distribuidos utilizamos el modelo cliente/servidor\n\nLa parte servidor\nRecibe peticiones, las procesa, devuelve respuestas\nPuede solicitar servicios a otros servidores\nEs escalable si puede aceptar otras peticiones antes de completar la petición en curso\n\n\n\n\nPara implementar un servidor escalable son posibles dos paradigmas:\n\nServidor concurrente\nServidor asincrónico\n\n\n\n\nServidor concurrente\n\nMúltiples hilos que se ejecutan de forma solapada en el tiempo\nCada petición se atendida por un hilo diferente\n\n\nEstado compartido. Todos los hilos comparten un estado global $\\rightarrow$ requiere mecanismos de control de concurrencia para garantizar atomicidad\nEs el modelo habitual (Java, .NET) $\\rightarrow$ estudiado en CSD\n\n\nServidor asincrónico\n\nDirigido por eventos. (nodeJS, Async .NET)\nPrograma = conjunto de acciones preparadas para responder a diferentes tipos de eventos (guarda $\\rightarrow$ acción, ..., guarda $\\rightarrow$ acción)\nSi la llegada de un evento hace cierta una guarda, la acción asociada se activa\nSi no estamos ejecutando otra cosa, ejecutamos la acción\nSi estamos ejecutando otra cosa, guardamos la acción en una cola\nCola de eventos (guarda las acciones activadas pero pendientes de ejecución)\n\n\n\n\n\n\nServidor asincrónico.- ejemplo (broker asincrónico)\nconst zmq = require(&#39;zeromq&#39;) // utilizara el middleware 0MQ bajo el nombre zmq\nlet sc = zmq.socket(&#39;router&#39;) // socket para conexión con clientes (frontend)\nlet sw = zmq.socket(&#39;dealer&#39;) // socket para conexión con workers  (backend)\nsc.bind(&#39;tcp://*:9998&#39;) // punto de conexión de clientes\nsw.bind(&#39;tcp://*:9999&#39;) // punto de conexión de workers\nsc.on(&#39;message&#39;, // guarda (si llega solicitud de un cliente)\n    (...m) =&gt; {sw.send(m)}) // acción (la reenvia a un worker)\nsw.on(&#39;message&#39;, // guarda (si llega respuesta de un worker)\n    (...m) =&gt; {sc.send(m)}) // acción (la reenvia al cliente)\n\n\nComparamos ventajas/inconvenientes de los dos modelos\n\nServidor concurrente\n\n$\\uparrow$ Cada hilo se puede suspender por separado\n$\\downarrow$ Gestionar el estado compartido requiere control concurrencia $\\rightarrow$ suspensión\n$\\downarrow$ Complejidad: difícil implantar sin errores, difícil razonar/justificar corrección\n\n\nServidor asincrónico\n\n$\\uparrow$ Evita la complejidad de gestionar estado compartido $\\rightarrow$ escala mejor\n$\\uparrow$ Modelo más próximo a la forma real de trabajo $\\rightarrow$ dirigido por eventos\nfacilita el razonamiento sobre la corrección del código\n\n\n$\\downarrow$ Tiene que considerarse el orden de activación (orden en la cola de eventos)\nNecesita una gestión adecuada del estado al implantar las acciones\n\n\n$\\downarrow$ Todo el entorno tiene que ser asincrónico (ej. también los servicios del S.O.)\n\n\n\n\nServidores escalables.- Cuestiones\nPlantéate las siguientes cuestiones\n\nEl ejemplo de servidor asincrónico (broker asincrónico) no parece tener ningún bucle. ¿Cuando acaba el programa?\nEl servidor asincrónico dispone solo de un hilo. ¿Qué pasa si mientras ejecuta código llega un evento?\n\n", "tags": "", "url": "sesion/servidoresEscalables/servidorsEscalables.html"},
		{"title": "Patró client/servidor", "text": "Patró client/servidor\nTSR 2020, Juansa Sendra, Grup A\n\nPatró client/servidor\n\nSocket tipus req en el client\nSupose definit var cs = zmq.socket(&#39;req&#39;) // cs = client Socket\ncs.connect(URL) (URL = &#39;ftp://IPserver:PortServer&#39;)\nEnviament: cs.send(msg) // msg pot ser multisegment\nPer a rebre cs.on(&#39;message&#39;, callback)\n\n\nSocket tipus rep en el servidor \nsupose definit var ss = zmq.socket(&#39;rep&#39;) // ss = server Socket\nss.bind(tcp://*:portServer)\nEnviament: ss.send(msg) // msg pot ser multisegment\nper a rebre ss.on(&#39;message&#39;, callback)\n\n\n\n\nCues\n\nentrada (recepció)\nmanté els missatges que han arribat fins passar-los a la aplicació\nla arribada d&#39;un missatge genera el esdeveniment &#39;message&#39;\n\n\neixida (envíament)\n\nmanté els missatges a enviar a altres agents\nguarda els missatges enviats per la aplicació\n|entrada|salida\n---|-------|------\nreq|1 cua  |1 cua\nrep|1 cua  |1 cua\n\n\n\n\n\nFuncionament sincrònic\n\nEl enviament i recepció NO són bloquejants\nemisor i receptor continuen funcionant de forma asincrónica\n\n\nPerò tots els parells petició/resposta està totalment ordenat\nPart client\nCuant el client envia petició a través de req, eixe missatge arriba al socket rep del servidor\nSi el client envia altra solicitud, es queda en la cua d&#39;eixida de req (no es completa l&#39;envíament), perque NO podems tindre més d&#39;una solicitud pendent per els clients.\nCuant arriba la resposta a la primera solicitud, s&#39;envia la segona petició desde la cua d&#39;eixida de req\n\n\nParte servidor\nCuant el servidor rep la primera solicitud (cua d&#39;entrada del socket rep) la aplicació recull i procesa eixe missatge\nSi arriba altra petició (de altre client), es manté en la cua d&#39;entrada del socket rep\nCuant s&#39;envía la resposta a la primera solicitud, es trau de la cua la segunda solicitud.\nNomés pot enviar una resposta a través de rep si hem rebut previament una solicitud por eixee mateix socket (el envíament es bloqueja fins a rebre la petició corresponent)\n\n\nSi un client envia n peticions per un socket, la segona, tercera, .. queden en cua local fins rebre resposta de la primera\n  figura\n\n\nEjemple 1:1\n// server.js\nconst zmq = require(&#39;zeromq&#39;)\nconst rp= zmq.socket(&#39;rep&#39;)\nrp.bind(&#39;tcp://*:8888&#39;,function(err) {if(err) throw err})\nrp.on(&#39;message&#39;, (msg)=&gt;{console.log(’Request: &#39;+msg); rp.send(’World&#39;)})\n\n// client.js\nconst zmq = require(&#39;zeromq&#39;)\nconst rq= zmq.socket(&#39;req&#39;)\nrq.connect(&#39;tcp://127.0.0.1:8888&#39;)\nrq.send(’Hello&#39;)\nrq.on(&#39;message&#39;, (msg)=&gt;{console.log(&#39;Response: &#39;+msg)})\n\n\nExample 1:n\n\nCada petició va a un rep diferent\nseguint política RR (Round Robin)\n\n\nIMPORTANT.- No podem mantiendre varies peticions pendents\nNO envia noves peticiones fins rebre la resposta a la actual\nNo hi ha paralelització de peticions\n\n\n\n// server1.js\nconst zmq = require(&#39;zeromq&#39;)\nconst rp= zmq.socket(&#39;rep&#39;)\nrp.bind(&#39;tcp://*:8889&#39;,function(err) {if(err) throw err})\nrp.on(&#39;message&#39;, (msg)=&gt;{console.log(’Request: &#39;+msg); rp.send(’World2&#39;)})\n\n// server2.js\nconst zmq = require(&#39;zeromq&#39;)\nconst rp= zmq.socket(&#39;rep&#39;)\nrp.bind(&#39;tcp://*:8888&#39;,function(err) {if(err) throw err})\nrp.on(&#39;message&#39;, (msg)=&gt;{console.log(’Request: &#39;+msg); rp.send(’World1&#39;)})\n\n// client.js\nconst zmq = require(&#39;zeromq&#39;)\nconst rq= zmq.socket(&#39;req&#39;)\nrq.connect(&#39;tcp://127.0.0.1:8888&#39;)\nrq.connect(&#39;tcp://127.0.0.1:8889&#39;)\nrq.send(’Hello1&#39;); rq.send(’Hello2&#39;); rq.send(’Hello3&#39;)\nrq.on(&#39;message&#39;, (msg)=&gt;{console.log(&#39;Response: &#39;+msg)})\n\n\nExample n:1\n\nConfiguració típica per a un servidor\nEl socket rep gestiona els missatges d&#39;entrada amb una cua FIFO\natén a tots els clients de manera equitativa (no hi ha inanició)\n\n\n\n// server.js\nconst zmq = require(&#39;zeromq&#39;)\nconst rp= zmq.socket(&#39;rep&#39;)\nrp.bind(&#39;tcp://*:8888&#39;,function(err) {if(err) throw err})\nrp.on(&#39;message&#39;, (msg)=&gt;{console.log(’Request: &#39;+msg); rp.send(’World&#39;)})\n\n// client1.js\nconst zmq = require(&#39;zeromq&#39;)\nconst rq= zmq.socket(&#39;req&#39;)\nrq.connect(&#39;tcp://127.0.0.1:8888&#39;)\nrq.send(’Hello1&#39;)\nrq.on(&#39;message&#39;, (msg)=&gt;{console.log(&#39;Response: &#39;+msg)})\n\n// client2.js\nconst zmq = require(&#39;zeromq&#39;)\nconst rq= zmq.socket(&#39;req&#39;)\nrq.connect(&#39;tcp://127.0.0.1:8888&#39;)\nrq.send(’Hello2&#39;)\nrq.on(&#39;message&#39;, (msg)=&gt;{console.log(&#39;Response: &#39;+msg)})\n\n\nCronograma i fallades\n\nCronograma 1:n sense fallades\nfigura\n\nCronograma 1:n amb fallades\n\nSi falla rep#2 el req que havia llanzat eixa sol.licitud no es recupera\ncal tancar la conexió y establir una nova\nfigura\n\n\n\n\nModificació del missatge (format missatges)\n\nEstructura missatge típic [envoltorio delimitador cos]\n\nenvolcall  = indica metadades associades al missatge\n\n1 o més segments\n-delimitador = segment buit que separa envolcall y cos (en la figura es representa usant una ,)\n1 o mas segmentos\n\n|envío                            |recepción\n----|-------------------------------|----------------\nreq |afig delimitador com a primer segment     |elimina primer seg (delimitador)\nrep |guarda envolcall, pasa cos a la aplic. |afig envolcall guardat\n\n\n\n\nfigura\n", "tags": "", "url": "sesion/zmq/reqrep.html"},
		{"title": "sockets", "text": "\n\n\nSocket\ncua entrada\ncua eixida\nsend\nreceive\n\n\n\n\nreq SYNC\n1\n1\n+,\n-,\n\n\nrep SYNC\n1\n1\n+ xxx,\n- xxx, (guarda)\n\n\npush\n-\n1\n\n\n\npull\n1\n-\n\n\n\npub\n-\n1\n\n\n\nsub\n1\n-\n\n\n\ndealer\n1\n1\n\n\n\nrouter\nN (1 per connex)\nN (1 per connex)\n-id\n+id \n\n\n\nsocket.identity(&#39;..&#39;)\nsub.subscribe(&#39;...&#39;)\n", "tags": "", "url": "sesion/zmq/sockets.html"},
		{"title": "Tema 3.- Middleware. ZeroMQ", "text": "Tema 3.- Middleware. ZeroMQ\nTSR 2021. Juansa Sendra, grupo B\n\nIntroducción\n\nDesarrollamos componentes de un sistema distribuido $\\rightarrow$ deben cooperar entre sí\nEj. servicio planificación de rutas: depende de servicio GIS (información distancias)\nEj. sistema de autorización: necesita servicio de reconocimiento biométrico\n\n\nComplicado\nPueden desarrollarse por programadores diferentes, con entornos de programación distintos\nMuchos detalles a considerar, especialmente para solicitar servicios\n¿Cómo localizar al servidor correcto? ¿Cuál es el API de un servicio? ¿Cómo construir/interpretar peticiones de servicio? ¿Cómo asociar a cliente la respuesta correcta? ...\n\n\nDepuración compleja\n¿Seguridad?\n¿Gestión de fallos?\n\n\n\n\nIntroducción.- Soluciones para reducir la complejidad\n\nUtilización de estándards\nFacilitan la interoperabilidad\nIntroducen formas racionales de hacer las cosas\nProporcionan funcionalidad de alto nivel\n\n\nReutilización de soluciones o componentes previos\nMenos código que escribir\nMas garantías\n\n\nMiddleware\nNivel de software y servicios entre las aplicaciones y el S.O.\nIntroduce transparencia de ... (ubicación, replicación, fallos, ...)\n\n\n\n\nMiddleware\n\nPerspectiva del programador\nImplantación sencilla (conceptos claros y bien definidos)\nResultado fiable (proporciona metodologia de desarrollo estandarizada y bien definida)\nSimplifica mantenimento (revisiones APIs)\n\n\nPerspectiva del administrador\nSimplifica instalación, configuración, actualización\nFacilita interoperabilidad (con productos de terceras partes)\n\n\n\n\nMiddleware orientado a comunicaciones (mensajería)\n\nComunicación flexible\nTransmisión atómica (todo o nada)\nTamaño arbitrario, mensajes estructurados\nGestión de colas, con ciertas garantías de orden\n\n\nNo impone visión de estado compartido\nEl estado compartido escala mal y puede provocar problemas de concurrencia\nAcoplamiento débil\n\n\nEncaja con el modelo &#39;dirigido por eventos&#39;\nImplícitamente asincrónico (desacopla emisor/receptor)\n\n\nClasificación de los sistemas de mensajeria\nPersistentes.- buffers para mensajes. No requieren receptor activo\nNo persistentes.- el receptor ha de estar activo para transmitir el mensaje\nCon gestor (ej. AMQP, JMS), o sin (ej. 0MQ) $\\downarrow$ garantías $\\uparrow$ escalable.\n\n\n\n\n\n\nZeroMQ.- Middleware de comunicaciones ...\n\nSimple\nURLs para identificar a los &#39;endpoints&#39;\nAPI similar a los sockets BSD (familiar): bind/connect, send/receive, ..\nMuchos tipos de sockets, para implantar varios patrones de comunicación\n\n\nÚnicamente es una biblioteca (no es necesario arrancar ningún servidor, etc.)\ninstalar: npm install zeromq@5 utilizar: const zmq = require(&#39;zeromq&#39;)\n\n\nModelo Entrada/salida asincrónica (dirigida por eventos)\n\n\nÀmplia disponibilidad (para muchos SO, lenguajes, entornos de programación)\nSoporta los principales patrones de interacción $\\rightarrow$ curva de aprendizaje rápida\nEficiente (compromiso fiabilidad/eficiencia) $\\rightarrow$ colas en memoria (en emisor/receptor)\nReutilizable. Mismo código para comunicar (cambiando solo las URL)\nHilos en un proceso, procesos en una máquina, ordenadores en red (TCP/IP)\n\n\n\n\n0MQ.- Tipos de Sockets y patrones de conexión\n\nEl tipo de socket a utilizar depende de los patrones de conexión\ncada patrón tiene necesidades diferents (utiliza sockets diferentes)\n\n\nClient/Server (sincrónico): req/rep\n\n\n\n0MQ.- Tipos de Sockets y patrones de conexión\n\nPipeline (unidireccional): push/pull\n\n\n\n0MQ.- Tipos de Sockets y patrones de conexión\n\nPublicación/subscripción (multienvío de mensajes, porque los receptores pueden decidir a qué mensajes se suscriben): pub/sub\n\n\n\n0MQ.- Tipos de Sockets y patrones de conexión\n\nOtros patrones (ej. broker/workers): router/dealer\n\n\n0MQ proporciona otros tipos (pair, xsub, xpub), pero NO los estudiamos \n\n\n\n0MQ.- Mensajes\n\nContenido de los mensajes transparente para 0MQ\nSoporta serialización (marshalling) y reconstrucción (unmarshalling) de cadenas (tiras de caracteres)\nEl programador decide cómo estructurar el contenido del mensaje\nCadena (lo que no sean cadenas se convierten primero a cadena)\nLas cadenas se convierten a buffers utilizando UTF8\nLuego las volvemos a convertir en cadenas (toString)\n\n\nPodemos utilizar estandards como JSON o XML\n\n\n\n\nLos mensajes se entregan de forma atómica (entrega todas las partes o ninguna)\nEnvio y recepción asincrónicos (no bloqueantes)\nInternamente 0MQ gestiona el flujo de mensajes entre colas de los procesos\n\n\nGestión de conexió/reconexió entre agentes automática\n\n\n0MQ.- Mensajes multisegmento\n\nLos mensajes pueden ser multisegmento\nsocket.send(&quot;text&quot;) // 4text  (1 segmento)\nsocket.send([&quot;Hola&quot;, &quot;&quot;, &quot;Ana&quot;]) // 4Hola03Ana (3 segmentos)\nEn la recepción podemos extraer los segmentos automáticamente (los argumentos del callback contienen los segmentos del mensaje)\nsock.on(&#39;message&#39;, function(s1,s2,s3) {..})\nO los recogemos en un vector\nsock.on(&#39;message&#39;, function(...msg) {for (let seg of msg) {..}})\n\n\nPodemos utilizar cada segmento para una pieza de información diferente\nEj. [nombreAPI, versionAPI, operación, arg, ..]\n\n\nDenominamos &#39;delimitador&#39; al primer segmento vacío (&quot;&quot;)\n\n\n\n\n0MQ.- Pasos para desarrollar una solución (ej. chat)\n\nIdentificamos los patrones de interacción (de donde derivamos qué tipos de sockets necessitamos, y dónde ubicarlos). Un chat combina:\nPipeline (clientes push, servidor pull)\nCada cliente envia msg al servidor cuando el usuario introduce una frase\n\n\nDifusión (clientes sub, servidor pub)\nEl servidor difunde a todos los clientes cada nueva frase\n\n\n\n\n\n\n\n0MQ.- Pasos para desarrollar una solución (ej. chat)\n\nDefine el formato de los mensajes a intercambiar\nCliente a servidor:  [remitente (autor de la frase = nick), text]\ntexto &#39;HI&#39; para darse de alta, texto &#39;BYE&#39; para darse de baja\n\n\nservidor a clientes: [autor de la frase(= nick), text]\nnick server si la frase la genera el servidor (ej. para avisar alta o baja de un cliente)\n\n\n\n\n\n\n\n0MQ.- Pasos para desarrollar una solución (ej. chat)\n\nDefine las respuestas de cada agente ante los eventos generados por los diferentes sockets\nCliente\nprocess.stdin.on(&#39;data&#39;,(str)=&gt;{psh.send([nick,str])}) //frase stdin\nprocess.stdin.on(&#39;end&#39;,()=&gt;{psh.send([nick,&#39;BYE&#39;])}) //cierre stdin\nsub.on(&#39;message&#39;, (nick,m) =&gt; {..}) //recibe mensaje del servidor\n\n\nServidor\npull.on(&#39;message&#39;, (nick,m) =&gt; {..}) //recibe mensaje del cliente\n\n\n\n\n\n\n0MQ.- Establecimiento connexión (bind/connect sobre TCP)\n\nGestión de conexión/reconexión entre agentes automática\nUn proceso (el que debería llegar primero y marcharse el último) realiza un bind\nsock.bind(&#39;tcp://*:5555&#39;, function(err) {..}) [5555]\n\n\nOtros procesos ($\\ge 1$) realizan un connect (usando la IP y socket del que hace bind)\nsock.connect(&#39;tcp://10.0.0.1:5555&#39;, function(err) {..})\n\n\nCuando un agente acaba ejecuta close implicito. Podemos invocarlo de forma explícita\nsock.close()\n\n\nAdemás de comunicación 1:1\nN:1 $\\rightarrow$ N clientes (cada uno 1 connect), 1 servidor (bind)\n1:N $\\rightarrow$ 1 cliente (N connect, uno a cada servidor), N servidores (cada uno 1 bind)\n\n\n\n\n0MQ.- Establecimiento connexión (bind/connect)\n\nNo es obligatorio un orden entre bind y connect. El primero que llega espera\nPodemos establecer conexiones 1:1, 1:N, N:1\nServidor 1\n  sock.bind(&#39;tcp://*:5555&#39;, function(err) {...}) [5555]\nServidor 2: \n  sock.bind(&#39;tcp://*:5556&#39;, function(err) {...}) [5556]\nCliente 1: \n  sock1.connect(&#39;tcp://10.0.0.1:5555&#39;, function(err) {...}) //a servidor 1\n  sock1.connect(&#39;tcp://10.0.0.1:5556&#39;, function(err) {...}) //a servidor 2\nCliente 2: \n  sock2.connect(&#39;tcp://10.0.0.1:5555&#39;, function(err) {...}) //a servidor 1\nCliente 3: \n  sock3.connect(&#39;tcp://10.0.0.1:5556&#39;, function(err) {...}) //a servidor 2\n\n\n\n\n0MQ en node\nconst zmq = require(&#39;zeromq&#39;) // importa biblioteca\nlet zsock = zmq.socket(&#39;tipusSocket&#39;)// creación socket (existen varios tipos)\nzsock.bind(&quot;tcp://*:5555&quot;) // bind en el port 5555\nzsock.connect(&quot;tcp://10.0.0.1:5555&quot;) // o connect (host 10.0.0.1, port 5555)\nzsock.send([..,..]) // envio\nzsock.on(&quot;message&quot;, callback) // recepción\nzsock.on(&quot;close&quot;, callback) // respuesta al cierre de la conexión\n\n\n0MQ.- código ejemplo servidor chat\nconst zmq = require(&#39;zeromq&#39;)\nlet pub = zmq.socket(&#39;pub&#39;)\nlet pull= zmq.socket(&#39;pull&#39;)\npub.bind (&#39;tcp://*:9998&#39;)\npull.bind(&#39;tcp://*:9999&#39;)\n\npull.on(&#39;message&#39;, (id,txt) =&gt; {\n   switch (txt.toString()) {\n     case &#39;HI&#39; : pub.send([&#39;server&#39;,id+&#39; connected&#39;]);    break\n     case &#39;BYE&#39;: pub.send([&#39;server&#39;,id+&#39; disconnected&#39;]); break\n     default   : pub.send([id,txt])\n   }\n})\n\n\n0MQ.- código ejemplo cliente chat\nconst zmq = require(&#39;zeromq&#39;)\nconst nick=&#39;Ana&#39;\nlet sub = zmq.socket(&#39;sub&#39;)\nlet psh = zmq.socket(&#39;push&#39;)\nsub.connect(&#39;tcp://127.0.0.1:9998&#39;)\npsh.connect(&#39;tcp://127.0.0.1:9999&#39;)\nsub.subscribe(&#39;&#39;) // subscrit a tots el missatges\n\nsub.on(&#39;message&#39;, (nick,m) =&gt; {console.log(&#39;[&#39;+nick+&#39;]&#39;+m)})\n\nprocess.stdin.resume()\nprocess.stdin.setEncoding(&#39;utf8&#39;)\nprocess.stdin.on(&#39;data&#39; ,(str)=&gt; {psh.send([nick, str.slice(0,-1)])})\nprocess.stdin.on(&#39;end&#39;,()=&gt; {psh.send([nick, &#39;BYE&#39;]); sub.close(); psh.close()})\nprocess.on(&#39;SIGINT&#39;,()=&gt; {process.stdin.end()})\n\npsh.send([nick,&#39;HI&#39;])\n\n\n0MQ.- Colas y opciones\n\nLos sockets pueden tener colas de mensajes asociadas\nDe entrada (recepción), para mantener los mensajes que llegan\ngeneran eventos &#39;message&#39; cuando llega un mensaje\n\n\nDe salida (envío), para mantener los mensajes a enviar a otros\n\n\nPodemos asociar algunas opciones a los sockets. Estudiamos únicamente 2:\nidentity.- Fija identidad del agente que se conecta a un router\nsubscribe.- Fija el filtro de prefijos aplicado al socket &#39;pub&#39;\n\n\nRouter es el único que puede enviar mensaje a un destino concreto, y sabe quién le ha enviado un mensaje\n\n\n0MQ.- Colas y opciones\n\n\n\nSocket\nCola entrada\nCola salida\nopciones\nsend\nreceive\n\n\n\n\nreq\n1\n1\nidentity\nm$\\rightarrow$[delim,m]\n[delim,m]$\\rightarrow$m\n\n\nrep\n1\n1\nidentity\nm$\\rightarrow$[a,delim,m]\n[a,delim,b]$\\rightarrow$b\n\n\npush\n\n1\nidentity\n\n\n\npull\n1\n\nidentity\n\n\n\npub\n\n1\n\n\n\n\nsub\n1\n\nsubscribe\n\n\n\nrouter\n1 por conex.\n1 por conex.\n\n[destino,m]$\\rightarrow$m\nm$\\rightarrow$[emisor,m]\n\n\ndealer\n1\n1\n\n\n\n\n\nOtros middleware\n\nGestión de eventos (ej. JINI)\nSe incluye con frecuencia en sistemes de mensajería\nPatrón publicador/subscriptor\n\n\n\n\nSeguridad\nAutenticación (ej. OpenID)\nUna tercera parte garantiza la identidad de un agente\n\n\nAutorización (ej. OAuth)\nUna tercera parte autoriza una petición\n\n\nIntegración con otros protocolos (ej. SSL/ TLS y HTTPS)\n\n\nSoporte transaccional\nCoordinación de modificaciones del estado distribuido (modificaciones atómicas)\nSoporta las situaciones de fallo\n\n\n\n\n\n\nConclusiones\n\nPara gestionar la complejidad de los sistemes distribuidos\nGestión adecuada del código y de los servicios\nUtilización de estandards\nUtilización middleware\n\n\nPrincipales objetivos middleware\nTareas de comunicaciones\nPetición de servicios\n\n\nPrincipales variantes middleware orientado a comunicaciones\nGestión mensajes persistente SI/NO\nBasados en gestor/sin gestor\n\n\nOtros middleware\nSeguridad\nTransacciones\n\n\n\n", "tags": "", "url": "sesion/zmq/zmq.html"},
		{"title": "Plan de trabajo", "text": "Plan de trabajo\nTeoria\n\n\n\nfecha\nTema\ntarea                                      \n\n\n\n\nMartes   7 sep\nPresentación\npresentació\n\n\nViernes 10 sep\nTema 1. Intro\nsesión 1.1 \n\n\nMartes  14 sep\n\nsesión 1.2 \n\n\nViernes 17 sep\nTema 2. NodeJS\nsesión 2.1 \n\n\nMartes  21 sep\n\nsesión 2.2 \n\n\nViernes 24 sep\n\nsesión 2.3    \n\n\nMartes  28 sep\n\nsesión 2.4 \n\n\nViernes  1 oct\n\nsesión 2.5 \n\n\nMartes   5 oct\n\nsesión 2.6 \n\n\nViernes  8 oct\n\nsesión 2.7    \n\n\nViernes 15 oct\nTema 3. 0MQ\nsesión 3.1 \n\n\nMartes  19 oct\n\nsesión 3.2    \n\n\nViernes 22 oct\n\nsesión 3.3    \n\n\nMartes  26 oct\n\nsesión 3.4 \n\n\nViernes 29 oct\n\nsesión 3.5 \n\n\nMartes   9 nov\n\nsesión 3.6    \n\n\nViernes 12 nov\nTema 4. Despliegue\nsessió 4.1     \n\n\nMartes  16 nov\n\nsesión 4.2    \n\n\nViernes 19 nov\n\nsesión 4.3 \n\n\nMartes  23 nov\n\nsesión 4.4 \n\n\nViernes 26 nov\n\nsesión 4.5 \n\n\nMartes  30 nov\n\nsesión 4.6    \n\n\nViernes  3 nov\nTema 5. Fallos\nsessió 5.1 \n\n\nMartes   7 dic\n\nsesión 5.3    \n\n\nViernes 10 dic\nTema 6. Escalabilidad\nsessió 6.1 \n\n\nMartes  14 dic\n\nsesión 6.2    \n\n\nViernes 17 dic\n\nsesión 6.3    \n\n\nMartes  21 dic\n\n(repaso)                        \n\n\n\nLab (B1)\n\n\n\nfecha\nProyecto\ntarea\n\n\n\n\nMartes  21 sep\n(lab0)\nlab 0.1\n\n\nMartes  28 sep\n(lab0)\nlab 0.2\n\n\nMiércoles  6 oct\nLab 1.- Node JS\nlab 1.1\n\n\nMiércoles 13 oct\n\nlab 1.2\n\n\nMiércoles 20 oct\n\nlab 1.3\n\n\nMiércoles 27 oct\nLab 2.- 0MQ\nlab 2.1\n\n\nMiércoles 10 nov\n\nlab 2.2\n\n\nMiércoles 17 nov\n\nlab 2.3\n\n\nMiércoles 24 nov\n\nlab 2.4\n\n\nMiércoles  1 dic\nLab 3.- Docker\nlab 3.1\n\n\nMiércoles 15 dic\n\nlab 3.2\n\n\nMiércoles 22 dic\n\nlab 3.3\n\n\n\nLab (B2)\n\n\n\nfecha\nProyecto\ntarea\n\n\n\n\nMartes  21 sep\n(lab0)\nlab 0.1\n\n\nMartes  28 sep\n(lab0)\nlab 0.2\n\n\nViernes  1 oct\nLab 1.- Node JS\nlab 1.1\n\n\nViernes  8 oct\n\nlab 1.2\n\n\nViernes 22 oct\n\nlab 1.3\n\n\nViernes 29 oct\nLab 2.- 0MQ\nlab 2.1\n\n\nViernes 12 nov\n\nlab 2.2\n\n\nViernes 19 nov\n\nlab 2.3\n\n\nViernes 26 nov\n\nlab 2.4\n\n\nViernes  3 dic\nLab 3.- Docker\nlab 3.1\n\n\nViernes 10 dic\n\nlab 3.2\n\n\nViernes 17 dic\n\nlab 3.3\n\n\n\n", "tags": "", "url": "tasques.html"},
		{"title": "Presentación", "text": "\nPresentación\nTecnologías de los Sistemas de Información en la Red\n\n\n\nÍndice\n\nMe presento\nObjetivos asignatura\nEstructura docencia\nTeoría\nLaboratorio\nEvaluación\nBibliografía\n\n\nMis datos\n\nnombre\ndespacho\ncorreo\nconsultas y tutorías\n\nHorario grupo\n\n...\n\n\nObjetivos Asignatura\n\nGeneral\nAproximación prágmática al diseño y construcción de Sistemas Distribuidos\n\n\nEspecíficos\nEntender las propiedades de los SD\nConocer las principales tecnologías y aproximaciones\nCapacitar para el diseño de la arquitectura adecuada para cada tipo de problema\n\n\n\n\nEstructura docencia\n\nAsignatura con 6 créditos\nTeoría (1.5 cr)\nPrincipios y propiedades generales\n\n\nSeminarios (3 cr)\nTecnologías básicas, ejemplos, resolución de problemas\n\n\nLaboratorio (1.5 cr)\nImplantación de soluciones a problemas tipo\n\n\n\n\n\nTeoría\n\n\n\nTema\ncontenido\nherramienta\n\n\n\n\nIntroducción\nintro SD, motivación\n\n\n\nNodeJS\njavascript y NodeJS\nNodeJS\n\n\nMiddleware\nMiddleware de mensajería\n0MQ\n\n\nDespliegue\nDespliegue\nDocker\n\n\nRobustez y fallos\nConsistencia\n\n\n\nEscalabilidad\n\ncluster, MongoDB\n\n\nEpílogo\n\n\n\n\n\n\nLaboratorio\n\n10 sesiones, a partir de la última semana de septiembre\nDetalle del día de cada sesión en calendario lab\n\n\n3 proyectos\nProxy inverso TCP/IP (3 sesiones). Usa javaScript (JS) y NodeJS (Node)\nAplicaciones en NodeJS con 0MQ (4 sesiones) Usa JS, Node, 0MQ\nDespliegue (3 sesiones). Usa JS, Node, Docker\n\n\n\n\nLaboratorio: conocimientos previos\n\njavaScript es distinto a Java\ndistinto modelo de tipos, soporte en ejecución, etc.\nDesarrollamos servidores asincrónicos (en CSD eran concurrentes)\n\n\nDamos material de autoaprendizaje para prepararse antes de la primera sesión enlace\n\n\nEvaluación\n\n\n\nfecha\nprueba\ntemario\nformato\npeso\nrecup\n\n\n\n\nxx\nPrimer parcial\ntemas 1..4, lab 1\ntest + resp abierta\n40%\nsi\n\n\nxx\nLab 2\nlab 2\nresp abierta\n20%\nsi \n\n\nxx\nSegundo parcial\ntemas 5..8, lab 3\ntest + resp abierta\n40%\nsi\n\n\n\n\nEvaluación: recuperación\n\nQueda la última nota\n\n\n\n\nfecha\nrecuperación\ntemario\nformato\npeso\n\n\n\n\nxx\nPrimer parcial\ntemas 1..4, lab 1\ntest + resp abierta\n40%\n\n\nxx\nLab 2\nlab 2\nresp abierta\n20% \n\n\nxx\nSegundo parcial\ntemas 5..8, lab 3\ntest + resp abierta\n40%\n\n\n\n\nBibliografía\n\nNo existe un texto que se corresponda exactamente a los contenidos del curso\nGuías de alumno para cada tema\nPueden suministrarse referencias adicionales en cada tema\n\n\nBibliografía ...\n\nMaterial disperso: artículos, libros, sitios web (mayoritariamente en inglés)\ntextos generales de consulta (ambos traducidos)\nDistributed Systems: Principles and Paradigms (2nd Ed). Andrew S. Tanenbaum, Maarten van Steen. Prentice Hall 2006\nDistributed Systems: Concepts and Design (5th Ed). George Coulouris, Jean Dollimore, ... Addison-Wesley 2011 \n\n\n\n\nBibliografía ...\n\nDocumentación concreta de tecnologías usadas\nnodeJS.org\n0MQ.org\ndocker.com \nmongodb.org\n\n\n\n\n¿Preguntas?\n", "tags": "", "url": "teoria/TSRpresentacion.html"},
		{"title": "Teoria", "text": "Teoria\nCada Unitat Temàtica conté:\n\nun joc de transparències\nuna guia de l&#39;alumne, que descriu amb detall el contingut de les transparències, facilitant el seu estudi\nPossiblement un conjunt de activitats proposades\nPossiblement referències externes o material complementari\n\n\n\n\nTema\ntransparències\nguia alumne\nactivitats\nvideos\ntranspa\n\n\n\n\ntema 0 (Presentación)\nhtml, pdf\n\n\n\n\ntema 1 (intro SD)\npdf\npdf\n\nwikipedia, escalabilitat, arees aplic., ciclo vida servicios\nintroAlternativa, áreas aplic, roles, servidores escalables\n\n\ntema 2 (nodeJS)\npdf\npdf\npdf\námbito vars (A), ámbito vars (B), invocación funciones, node JS (A), node JS (B), extra JavaScript (A), extra JavaScript (B)\námbito vars, ámbito vars (alt)\n\n\ntema 3 (zmq)\npdf\npdf\npdf\nzmq (A), zmq (B), zmq (C), pipeline, difussión, router y dealer, broker/workers (A), broker/workers (B)\nreq/rep, pipeline i difusión, router y dealer, zmq (pdf), zmq (html), sockets zmq\n\n\ntema 4 (despliegue)\npdf\npdf\npdf\ndespliegue 1, despliegue 2, despliegue 3, desplegament 4, desplegament 5\nhtml\n\n\ntema 5 (gestión fallos)\npdf\npdf\npdf\nfallos1, fallos2, fallos3, fallos4\nhtml\n\n\ntema 6 (escalabilidad)\npdf\npdf\npdf\nescalab1, escalab2, escalab3, escalab4, escalab5\nhtml\n\n\n\n\n\nPresentación\n\nObjectivos de la assignatura, y su contenido teórico y práctico\nDetalla la organización docente y el calendario de trabajo\nEstablece la normativa de evaluación\nProporciona referencias al material de consulta\n\n\nIntroducción a los Sistemas Distribuidos\n\nRepasa el concepto de Sistema Distribuido (SD) (estudiado en la asignatura CSD)\nDescribe algunos ejemplos y áreas de aplicación\nRepasa la evolución històrica, hasta Cloud COmputing (CC)\nCompara las dos posibles alternativas para implantar servidores escalables:\nServidores concurrentes\nServidores asincrónicos\n\n\n\n\nNodeJS\nIntroduce el uso de JavaScript y NodeJS para implantar servidores asincrónicos\núnicamente estudiamos la parte de JS necesaria para esta assignatura\n\n\nProporciona los contenidos previos necesarios para el desarrollo de les prácticas de laboratorio\n\n\n0MQ\nRepasa el concepto de middleware, especialmente el middleware orientado a comunicaciones\nIntroduce 0MQ como un ejemplo de middleware orientado a comunicaciones\nPosteriormente se utilitza en las prácticas de laboratorio\nLa combinación de NodeJS y 0MQ permite construir servidores escalables y tolerantes a fallos con relativamente poco código\n\n\n\n\nDespliegue\nLa configuración y arranque de un SD requiere el despliegue de diversos components software en nodos distintos. Cada nodo debe coneixer algunos aspectos básicos del sistema para poder interactuar con otros componentes\nEsta unidad temática presenta mecanismos para automatizar esas tareas (configurar la cantidad de instancias de cada componente, su ubicación, y la forma en que los distintos componentes interactuan entre sí\nIntroduce la herramienta Docker, que posteriormente utilizamos en el laboratorio\n\n\nGestión de fallos\nCaracteriza las situaciones de fallo en un SD\nEstudia los modelos de replicación\nIdentifica los modelos de consistencia\n\n\nEscalabilidad\nIdentifica\nLos mecanismos básicos para mejorar la escalabilidad\nLos aspectos que pueden comprometer la escalabilidad (puntos de contención)\n\n\nTrata la escalabilidad a nivel de datos (almacenes escalables $\\rightarrow$ noSQL)\nPresenta ejemplos de escalabilidad a distintos niveles\n\n\n\n\n", "tags": "", "url": "teoria.html"}
	]
}
